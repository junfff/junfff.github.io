<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Rust on junfff blog </title>
    <link>http://example.org/categories/rust/</link>
    <description>Recent content in Rust on junfff blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://example.org/categories/rust/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Rust::Channels</title>
      <link>http://example.org/posts/rust/2020-12-27-rust-channels/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/rust/2020-12-27-rust-channels/</guid>
      <description>Flavors:  Synchronous channels: Channel where send() can block. Limited capacity.  Mutex + Condvar + VecDeque Atomic VecDeque (atomic queue) + thread::pack + thread::Thread::notify   Asynchronous channels: Channel where send() cannot block. Unbounded.  Mutex + Condvar + VecDeque Mutex + Condvar + LinkedList AtomicLinkedList or Atomic Queue Atomic linked list, linked list of T Atomic block linked list, linked of atomic VecDeque   Rendezvous channels: Synchronous with capacity = 0.</description>
    </item>
    
    <item>
      <title>Rust::mio</title>
      <link>http://example.org/posts/rust/2021-02-23-rust-mio-epoll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/rust/2021-02-23-rust-mio-epoll/</guid>
      <description>Flavors:  from url: https://blog.csdn.net/s_lisheng/article/details/80593426  【Rust】轻量级I/O库mio
让我思考一下 2018-06-06 12:53:45 4054 收藏 3 分类专栏： Rust 文章标签： Rust mio 版权 mio是rust实现的一个轻量级的I/O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。Linux下为epoll，Windows下为IOCP，OS X下为kqueue。
一、关于mio 1、重要特性 非阻塞TCP，UDP I/O事件通知epoll,kqeue,IOCP实现 运行时零分配 平台可扩展 2、基础用法 其使用方法与Linux中epoll差不多，mio底层封装了epoll，使用步骤思路：
创建Poll 注册事件 事件循环等待与处理事件 mio提供可跨平台的sytem selector访问，不同平台如下表，都可调用相同的API。不同平台使用的API开销不尽相同。由于mio是基于readiness(就绪状态)的API，与Linux epoll相似，可以看到很多API在Linux上都可以一对一映射。相比之下，Windows IOCP是基于完成（completion-based）而非基于就绪的API，所以两者间会有较多桥接。 同时mio提供自身版本的TcpListener、TcpStream、UdpSocket，这些API封装了底层平台相关API，并设为非阻塞且实现Evented trait。
OS	Selector Linux	epoll OS X, iOS	kqueue Windows	IOCP FreeBSD	kqueue Android	epoll mio实现的是一个单线程事件循环，并没有实现线程池及多线程事件循环，如果需要线程池及多线程事件循环等需要自己实现。
二、源码分析 先给出mio的源码目录结构，只列出了关键的部分，如下所示：
mio代码目录结构 mio |&amp;mdash;-&amp;gt;test |&amp;mdash;-&amp;gt;src |&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;deprecated	//事件循环代码 |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;event_loop.rs	//EventLoop的实现，内部封装了Poll	【1】 |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;handler.rs	//供上层实现的接口 |&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;net |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;mod.rs |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;tcp.rs |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;udp.rs |&amp;mdash;&amp;mdash;&amp;ndash;&amp;gt;sys	//不同系统下的实现 |&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;gt;mod.</description>
    </item>
    
  </channel>
</rss>
