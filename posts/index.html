<!DOCTYPE html>
<html>
<head>
    <title>Blog</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="http://example.org/assets/css/main.css"/>
    <link rel="canonical" href="http://example.org/posts/">
    <noscript><link rel="stylesheet" href="http://example.org/assets/css/noscript.css"/></noscript>
    <style>
        :root{--site-background : url("http://example.org/images/bg.jpg")};
    </style> 
    
    <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>
</head>


<body class="is-preload">

    
        <div id="wrapper">

            
                <header id="header">
                    <div class="logo">
                        <a href="/">
                            <span class="icon">
                                <img src="">
                            </span>
                        </a>
                    </div>
                    <div class="content">
                        <div class="inner">
                            <h1>Blog</h1>
                            
                        </div>
                    </div>
                    <nav>
                        <ul>
                            
                                
                                    
                                        <li>
                                            <a href="#archlinux-tes9999999">ArchLinux Tes9999999</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#archlinux-test">ArchLinux Test</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#archlinux-test123">ArchLinux Test123</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#qxjjaexpbnv45a%2bg6zkl546v">ArchLinux密钥环</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#helloworld">HelloWorld</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#sw50zxj2awv3ojpdkyvomzrlh73mlbat5p6e6ycg5ye95pww">Interview::C&#43;&#43;虚函数-构造函数</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#interviewfive-ball-select-two">Interview::five-ball-select-two</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#interviewfor-for-for">Interview::for-for-for</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#interviewunity">Interview::unity</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#rustchannels">Rust::Channels</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#rustmio">Rust::mio</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#vw5pdhk6okdd55qe5a6e546w">Unity::GC的实现</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#5l2g5aw977ym5liw55wm">你好，世界</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#migrate-to-hugo-from-jekyll">Migrate to Hugo from Jekyll</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#hugo-template-primer">(Hu)go Template Primer</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#getting-started-with-hugo">Getting Started with Hugo</a>
                                        </li>
                                    
                                
                            
                                
                                    
                                        <li>
                                            <a href="#creating-a-new-theme">Creating a New Theme</a>
                                        </li>
                                    
                                
                            
                        </ul>
                    </nav>
                </header>

            
                <div id="main">

                    
                        
                            
                                <article id="creating-a-new-theme">
                                    <h2 class="major">Creating a New Theme</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h2 id="introduction">Introduction</h2>
<p>This tutorial will show you how to create a simple theme in Hugo. I assume that you are familiar with HTML, the bash command line, and that you are comfortable using Markdown to format content. I&rsquo;ll explain how Hugo uses templates and how you can organize your templates to create a theme. I won&rsquo;t cover using CSS to style your theme.</p>
<p>We&rsquo;ll start with creating a new site with a very basic template. Then we&rsquo;ll add in a few pages and posts. With small variations on that, you will be able to create many different types of web sites.</p>
<p>In this tutorial, commands that you enter will start with the &ldquo;$&rdquo; prompt. The output will follow. Lines that start with &ldquo;#&rdquo; are comments that I&rsquo;ve added to explain a point. When I show updates to a file, the &ldquo;:wq&rdquo; on the last line means to save the file.</p>
<p>Here&rsquo;s an example:</p>
<pre tabindex="0"><code>## this is a comment
$ echo this is a command
this is a command

## edit the file
$ vi foo.md
+++
date = &#34;2014-09-28&#34;
title = &#34;creating a new theme&#34;
+++

bah and humbug
:wq

## show it
$ cat foo.md
+++
date = &#34;2014-09-28&#34;
title = &#34;creating a new theme&#34;
+++

bah and humbug
$
</code></pre><h2 id="some-definitions">Some Definitions</h2>
<p>There are a few concepts that you need to understand before creating a theme.</p>
<h3 id="skins">Skins</h3>
<p>Skins are the files responsible for the look and feel of your site. It’s the CSS that controls colors and fonts, it’s the Javascript that determines actions and reactions. It’s also the rules that Hugo uses to transform your content into the HTML that the site will serve to visitors.</p>
<p>You have two ways to create a skin. The simplest way is to create it in the <code>layouts/</code> directory. If you do, then you don’t have to worry about configuring Hugo to recognize it. The first place that Hugo will look for rules and files is in the <code>layouts/</code> directory so it will always find the skin.</p>
<p>Your second choice is to create it in a sub-directory of the <code>themes/</code> directory. If you do, then you must always tell Hugo where to search for the skin. It’s extra work, though, so why bother with it?</p>
<p>The difference between creating a skin in <code>layouts/</code> and creating it in <code>themes/</code> is very subtle. A skin in <code>layouts/</code> can’t be customized without updating the templates and static files that it is built from. A skin created in <code>themes/</code>, on the other hand, can be and that makes it easier for other people to use it.</p>
<p>The rest of this tutorial will call a skin created in the <code>themes/</code> directory a theme.</p>
<p>Note that you can use this tutorial to create a skin in the <code>layouts/</code> directory if you wish to. The main difference will be that you won’t need to update the site’s configuration file to use a theme.</p>
<h3 id="the-home-page">The Home Page</h3>
<p>The home page, or landing page, is the first page that many visitors to a site see. It is the index.html file in the root directory of the web site. Since Hugo writes files to the public/ directory, our home page is public/index.html.</p>
<h3 id="site-configuration-file">Site Configuration File</h3>
<p>When Hugo runs, it looks for a configuration file that contains settings that override default values for the entire site. The file can use TOML, YAML, or JSON. I prefer to use TOML for my configuration files. If you prefer to use JSON or YAML, you’ll need to translate my examples. You’ll also need to change the name of the file since Hugo uses the extension to determine how to process it.</p>
<p>Hugo translates Markdown files into HTML. By default, Hugo expects to find Markdown files in your <code>content/</code> directory and template files in your <code>themes/</code> directory. It will create HTML files in your <code>public/</code> directory. You can change this by specifying alternate locations in the configuration file.</p>
<h3 id="content">Content</h3>
<p>Content is stored in text files that contain two sections. The first section is the “front matter,” which is the meta-information on the content. The second section contains Markdown that will be converted to HTML.</p>
<h4 id="front-matter">Front Matter</h4>
<p>The front matter is information about the content. Like the configuration file, it can be written in TOML, YAML, or JSON. Unlike the configuration file, Hugo doesn’t use the file’s extension to know the format. It looks for markers to signal the type. TOML is surrounded by “<code>+++</code>”, YAML by “<code>---</code>”, and JSON is enclosed in curly braces. I prefer to use TOML, so you’ll need to translate my examples if you prefer YAML or JSON.</p>
<p>The information in the front matter is passed into the template before the content is rendered into HTML.</p>
<h4 id="markdown">Markdown</h4>
<p>Content is written in Markdown which makes it easier to create the content. Hugo runs the content through a Markdown engine to create the HTML which will be written to the output file.</p>
<h3 id="template-files">Template Files</h3>
<p>Hugo uses template files to render content into HTML. Template files are a bridge between the content and presentation. Rules in the template define what content is published, where it&rsquo;s published to, and how it will rendered to the HTML file. The template guides the presentation by specifying the style to use.</p>
<p>There are three types of templates: single, list, and partial. Each type takes a bit of content as input and transforms it based on the commands in the template.</p>
<p>Hugo uses its knowledge of the content to find the template file used to render the content. If it can’t find a template that is an exact match for the content, it will shift up a level and search from there. It will continue to do so until it finds a matching template or runs out of templates to try. If it can’t find a template, it will use the default template for the site.</p>
<p>Please note that you can use the front matter to influence Hugo’s choice of templates.</p>
<h4 id="single-template">Single Template</h4>
<p>A single template is used to render a single piece of content. For example, an article or post would be a single piece of content and use a single template.</p>
<h4 id="list-template">List Template</h4>
<p>A list template renders a group of related content. That could be a summary of recent postings or all articles in a category. List templates can contain multiple groups.</p>
<p>The homepage template is a special type of list template. Hugo assumes that the home page of your site will act as the portal for the rest of the content in the site.</p>
<h4 id="partial-template">Partial Template</h4>
<p>A partial template is a template that can be included in other templates. Partial templates must be called using the “partial” template command. They are very handy for rolling up common behavior. For example, your site may have a banner that all pages use. Instead of copying the text of the banner into every single and list template, you could create a partial with the banner in it. That way if you decide to change the banner, you only have to change the partial template.</p>
<h2 id="create-a-new-site">Create a New Site</h2>
<p>Let&rsquo;s use Hugo to create a new web site. I&rsquo;m a Mac user, so I&rsquo;ll create mine in my home directory, in the Sites folder. If you&rsquo;re using Linux, you might have to create the folder first.</p>
<p>The &ldquo;new site&rdquo; command will create a skeleton of a site. It will give you the basic directory structure and a useable configuration file.</p>
<pre tabindex="0"><code>$ hugo new site ~/Sites/zafta
$ cd ~/Sites/zafta
$ ls -l
total 8
drwxr-xr-x  7 quoha  staff  238 Sep 29 16:49 .
drwxr-xr-x  3 quoha  staff  102 Sep 29 16:49 ..
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes
-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static
$
</code></pre><p>Take a look in the content/ directory to confirm that it is empty.</p>
<p>The other directories (archetypes/, layouts/, and static/) are used when customizing a theme. That&rsquo;s a topic for a different tutorial, so please ignore them for now.</p>
<h3 id="generate-the-html-for-the-new-site">Generate the HTML For the New Site</h3>
<p>Running the <code>hugo</code> command with no options will read all the available content and generate the HTML files. It will also copy all static files (that&rsquo;s everything that&rsquo;s not content). Since we have an empty site, it won&rsquo;t do much, but it will do it very quickly.</p>
<pre tabindex="0"><code>$ hugo --verbose
INFO: 2014/09/29 Using config file: config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
WARN: 2014/09/29 Unable to locate layout: [404.html]
0 draft content 
0 future content 
0 pages created 
0 tags created
0 categories created
in 2 ms
$ 
</code></pre><p>The &ldquo;<code>--verbose</code>&rdquo; flag gives extra information that will be helpful when we build the template. Every line of the output that starts with &ldquo;INFO:&rdquo; or &ldquo;WARN:&rdquo; is present because we used that flag. The lines that start with &ldquo;WARN:&rdquo; are warning messages. We&rsquo;ll go over them later.</p>
<p>We can verify that the command worked by looking at the directory again.</p>
<pre tabindex="0"><code>$ ls -l
total 8
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes
-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:02 public
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static
$
</code></pre><p>See that new public/ directory? Hugo placed all generated content there. When you&rsquo;re ready to publish your web site, that&rsquo;s the place to start. For now, though, let&rsquo;s just confirm that we have what we&rsquo;d expect from a site with no content.</p>
<pre tabindex="0"><code>$ ls -l public
total 16
-rw-r--r--  1 quoha  staff  416 Sep 29 17:02 index.xml
-rw-r--r--  1 quoha  staff  262 Sep 29 17:02 sitemap.xml
$ 
</code></pre><p>Hugo created two XML files, which is standard, but there are no HTML files.</p>
<h3 id="test-the-new-site">Test the New Site</h3>
<p>Verify that you can run the built-in web server. It will dramatically shorten your development cycle if you do. Start it by running the &ldquo;server&rdquo; command. If it is successful, you will see output similar to the following:</p>
<pre tabindex="0"><code>$ hugo server --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
WARN: 2014/09/29 Unable to locate layout: [404.html]
0 draft content 
0 future content 
0 pages created 
0 tags created
0 categories created
in 2 ms
Serving pages from /Users/quoha/Sites/zafta/public
Web Server is available at http://localhost:1313
Press Ctrl+C to stop
</code></pre><p>Connect to the listed URL (it&rsquo;s on the line that starts with &ldquo;Web Server&rdquo;). If everything is working correctly, you should get a page that shows the following:</p>
<pre tabindex="0"><code>index.xml
sitemap.xml
</code></pre><p>That&rsquo;s a listing of your public/ directory. Hugo didn&rsquo;t create a home page because our site has no content. When there&rsquo;s no index.html file in a directory, the server lists the files in the directory, which is what you should see in your browser.</p>
<p>Let’s go back and look at those warnings again.</p>
<pre tabindex="0"><code>WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
WARN: 2014/09/29 Unable to locate layout: [404.html]
</code></pre><p>That second warning is easier to explain. We haven’t created a template to be used to generate “page not found errors.” The 404 message is a topic for a separate tutorial.</p>
<p>Now for the first warning. It is for the home page. You can tell because the first layout that it looked for was “index.html.” That’s only used by the home page.</p>
<p>I like that the verbose flag causes Hugo to list the files that it&rsquo;s searching for. For the home page, they are index.html, _default/list.html, and _default/single.html. There are some rules that we&rsquo;ll cover later that explain the names and paths. For now, just remember that Hugo couldn&rsquo;t find a template for the home page and it told you so.</p>
<p>At this point, you&rsquo;ve got a working installation and site that we can build upon. All that’s left is to add some content and a theme to display it.</p>
<h2 id="create-a-new-theme">Create a New Theme</h2>
<p>Hugo doesn&rsquo;t ship with a default theme. There are a few available (I counted a dozen when I first installed Hugo) and Hugo comes with a command to create new themes.</p>
<p>We&rsquo;re going to create a new theme called &ldquo;zafta.&rdquo; Since the goal of this tutorial is to show you how to fill out the files to pull in your content, the theme will not contain any CSS. In other words, ugly but functional.</p>
<p>All themes have opinions on content and layout. For example, Zafta uses &ldquo;post&rdquo; over &ldquo;blog&rdquo;. Strong opinions make for simpler templates but differing opinions make it tougher to use themes. When you build a theme, consider using the terms that other themes do.</p>
<h3 id="create-a-skeleton">Create a Skeleton</h3>
<p>Use the hugo &ldquo;new&rdquo; command to create the skeleton of a theme. This creates the directory structure and places empty files for you to fill out.</p>
<pre tabindex="0"><code>$ hugo new theme zafta

$ ls -l
total 8
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 archetypes
-rw-r--r--  1 quoha  staff   82 Sep 29 16:49 config.toml
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 content
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 layouts
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:02 public
drwxr-xr-x  2 quoha  staff   68 Sep 29 16:49 static
drwxr-xr-x  3 quoha  staff  102 Sep 29 17:31 themes

$ find themes -type f | xargs ls -l
-rw-r--r--  1 quoha  staff  1081 Sep 29 17:31 themes/zafta/LICENSE.md
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/archetypes/default.md
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/_default/list.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/_default/single.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/index.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html
-rw-r--r--  1 quoha  staff     0 Sep 29 17:31 themes/zafta/layouts/partials/header.html
-rw-r--r--  1 quoha  staff    93 Sep 29 17:31 themes/zafta/theme.toml
$ 
</code></pre><p>The skeleton includes templates (the files ending in .html), license file, a description of your theme (the theme.toml file), and an empty archetype.</p>
<p>Please take a minute to fill out the theme.toml and LICENSE.md files. They&rsquo;re optional, but if you&rsquo;re going to be distributing your theme, it tells the world who to praise (or blame). It&rsquo;s also nice to declare the license so that people will know how they can use the theme.</p>
<pre tabindex="0"><code>$ vi themes/zafta/theme.toml
author = &#34;michael d henderson&#34;
description = &#34;a minimal working template&#34;
license = &#34;MIT&#34;
name = &#34;zafta&#34;
source_repo = &#34;&#34;
tags = [&#34;tags&#34;, &#34;categories&#34;]
:wq

## also edit themes/zafta/LICENSE.md and change
## the bit that says &#34;YOUR_NAME_HERE&#34;
</code></pre><p>Note that the the skeleton&rsquo;s template files are empty. Don&rsquo;t worry, we&rsquo;ll be changing that shortly.</p>
<pre tabindex="0"><code>$ find themes/zafta -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/list.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/single.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/index.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/partials/footer.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/partials/header.html
$
</code></pre><h3 id="update-the-configuration-file-to-use-the-theme">Update the Configuration File to Use the Theme</h3>
<p>Now that we&rsquo;ve got a theme to work with, it&rsquo;s a good idea to add the theme name to the configuration file. This is optional, because you can always add &ldquo;-t zafta&rdquo; on all your commands. I like to put it the configuration file because I like shorter command lines. If you don&rsquo;t put it in the configuration file or specify it on the command line, you won&rsquo;t use the template that you&rsquo;re expecting to.</p>
<p>Edit the file to add the theme, add a title for the site, and specify that all of our content will use the TOML format.</p>
<pre tabindex="0"><code>$ vi config.toml
theme = &#34;zafta&#34;
baseurl = &#34;&#34;
languageCode = &#34;en-us&#34;
title = &#34;zafta - totally refreshing&#34;
MetaDataFormat = &#34;toml&#34;
:wq

$
</code></pre><h3 id="generate-the-site">Generate the Site</h3>
<p>Now that we have an empty theme, let&rsquo;s generate the site again.</p>
<pre tabindex="0"><code>$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
0 pages created 
0 tags created
0 categories created
in 2 ms
$
</code></pre><p>Did you notice that the output is different? The warning message for the home page has disappeared and we have an additional information line saying that Hugo is syncing from the theme&rsquo;s directory.</p>
<p>Let&rsquo;s check the public/ directory to see what Hugo&rsquo;s created.</p>
<pre tabindex="0"><code>$ ls -l public
total 16
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:56 css
-rw-r--r--  1 quoha  staff    0 Sep 29 17:56 index.html
-rw-r--r--  1 quoha  staff  407 Sep 29 17:56 index.xml
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:56 js
-rw-r--r--  1 quoha  staff  243 Sep 29 17:56 sitemap.xml
$
</code></pre><p>Notice four things:</p>
<ol>
<li>Hugo created a home page. This is the file public/index.html.</li>
<li>Hugo created a css/ directory.</li>
<li>Hugo created a js/ directory.</li>
<li>Hugo claimed that it created 0 pages. It created a file and copied over static files, but didn&rsquo;t create any pages. That&rsquo;s because it considers a &ldquo;page&rdquo; to be a file created directly from a content file. It doesn&rsquo;t count things like the index.html files that it creates automatically.</li>
</ol>
<h4 id="the-home-page-1">The Home Page</h4>
<p>Hugo supports many different types of templates. The home page is special because it gets its own type of template and its own template file. The file, layouts/index.html, is used to generate the HTML for the home page. The Hugo documentation says that this is the only required template, but that depends. Hugo&rsquo;s warning message shows that it looks for three different templates:</p>
<pre tabindex="0"><code>WARN: 2014/09/29 Unable to locate layout: [index.html _default/list.html _default/single.html]
</code></pre><p>If it can&rsquo;t find any of these, it completely skips creating the home page. We noticed that when we built the site without having a theme installed.</p>
<p>When Hugo created our theme, it created an empty home page template. Now, when we build the site, Hugo finds the template and uses it to generate the HTML for the home page. Since the template file is empty, the HTML file is empty, too. If the template had any rules in it, then Hugo would have used them to generate the home page.</p>
<pre tabindex="0"><code>$ find . -name index.html | xargs ls -l
-rw-r--r--  1 quoha  staff  0 Sep 29 20:21 ./public/index.html
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 ./themes/zafta/layouts/index.html
$ 
</code></pre><h4 id="the-magic-of-static">The Magic of Static</h4>
<p>Hugo does two things when generating the site. It uses templates to transform content into HTML and it copies static files into the site. Unlike content, static files are not transformed. They are copied exactly as they are.</p>
<p>Hugo assumes that your site will use both CSS and JavaScript, so it creates directories in your theme to hold them. Remember opinions? Well, Hugo&rsquo;s opinion is that you&rsquo;ll store your CSS in a directory named css/ and your JavaScript in a directory named js/. If you don&rsquo;t like that, you can change the directory names in your theme directory or even delete them completely. Hugo&rsquo;s nice enough to offer its opinion, then behave nicely if you disagree.</p>
<pre tabindex="0"><code>$ find themes/zafta -type d | xargs ls -ld
drwxr-xr-x  7 quoha  staff  238 Sep 29 17:38 themes/zafta
drwxr-xr-x  3 quoha  staff  102 Sep 29 17:31 themes/zafta/archetypes
drwxr-xr-x  5 quoha  staff  170 Sep 29 17:31 themes/zafta/layouts
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/layouts/_default
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/layouts/partials
drwxr-xr-x  4 quoha  staff  136 Sep 29 17:31 themes/zafta/static
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:31 themes/zafta/static/css
drwxr-xr-x  2 quoha  staff   68 Sep 29 17:31 themes/zafta/static/js
$ 
</code></pre><h2 id="the-theme-development-cycle">The Theme Development Cycle</h2>
<p>When you&rsquo;re working on a theme, you will make changes in the theme&rsquo;s directory, rebuild the site, and check your changes in the browser. Hugo makes this very easy:</p>
<ol>
<li>Purge the public/ directory.</li>
<li>Run the built in web server in watch mode.</li>
<li>Open your site in a browser.</li>
<li>Update the theme.</li>
<li>Glance at your browser window to see changes.</li>
<li>Return to step 4.</li>
</ol>
<p>I’ll throw in one more opinion: never work on a theme on a live site. Always work on a copy of your site. Make changes to your theme, test them, then copy them up to your site. For added safety, use a tool like Git to keep a revision history of your content and your theme. Believe me when I say that it is too easy to lose both your mind and your changes.</p>
<p>Check the main Hugo site for information on using Git with Hugo.</p>
<h3 id="purge-the-public-directory">Purge the public/ Directory</h3>
<p>When generating the site, Hugo will create new files and update existing ones in the <code>public/</code> directory. It will not delete files that are no longer used. For example, files that were created in the wrong directory or with the wrong title will remain. If you leave them, you might get confused by them later. I recommend cleaning out your site prior to generating it.</p>
<p>Note: If you&rsquo;re building on an SSD, you should ignore this. Churning on a SSD can be costly.</p>
<h3 id="hugos-watch-option">Hugo&rsquo;s Watch Option</h3>
<p>Hugo&rsquo;s &ldquo;<code>--watch</code>&rdquo; option will monitor the content/ and your theme directories for changes and rebuild the site automatically.</p>
<h3 id="live-reload">Live Reload</h3>
<p>Hugo&rsquo;s built in web server supports live reload. As pages are saved on the server, the browser is told to refresh the page. Usually, this happens faster than you can say, &ldquo;Wow, that&rsquo;s totally amazing.&rdquo;</p>
<h3 id="development-commands">Development Commands</h3>
<p>Use the following commands as the basis for your workflow.</p>
<pre tabindex="0"><code>## purge old files. hugo will recreate the public directory.
##
$ rm -rf public
##
## run hugo in watch mode
##
$ hugo server --watch --verbose
</code></pre><p>Here&rsquo;s sample output showing Hugo detecting a change to the template for the home page. Once generated, the web browser automatically reloaded the page. I&rsquo;ve said this before, it&rsquo;s amazing.</p>
<pre tabindex="0"><code>$ rm -rf public
$ hugo server --watch --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
0 pages created 
0 tags created
0 categories created
in 2 ms
Watching for changes in /Users/quoha/Sites/zafta/content
Serving pages from /Users/quoha/Sites/zafta/public
Web Server is available at http://localhost:1313
Press Ctrl+C to stop
INFO: 2014/09/29 File System Event: [&#34;/Users/quoha/Sites/zafta/themes/zafta/layouts/index.html&#34;: MODIFY|ATTRIB]
Change detected, rebuilding site

WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
0 pages created 
0 tags created
0 categories created
in 1 ms
</code></pre><h2 id="update-the-home-page-template">Update the Home Page Template</h2>
<p>The home page is one of a few special pages that Hugo creates automatically. As mentioned earlier, it looks for one of three files in the theme&rsquo;s layout/ directory:</p>
<ol>
<li>index.html</li>
<li>_default/list.html</li>
<li>_default/single.html</li>
</ol>
<p>We could update one of the default templates, but a good design decision is to update the most specific template available. That&rsquo;s not a hard and fast rule (in fact, we&rsquo;ll break it a few times in this tutorial), but it is a good generalization.</p>
<h3 id="make-a-static-home-page">Make a Static Home Page</h3>
<p>Right now, that page is empty because we don&rsquo;t have any content and we don&rsquo;t have any logic in the template. Let&rsquo;s change that by adding some text to the template.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/index.html
&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;body&gt; 
  &lt;p&gt;hugo says hello!&lt;/p&gt; 
&lt;/body&gt; 
&lt;/html&gt; 
:wq

$
</code></pre><p>Build the web site and then verify the results.</p>
<pre tabindex="0"><code>$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
0 pages created 
0 tags created
0 categories created
in 2 ms

$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  78 Sep 29 21:26 public/index.html

$ cat public/index.html 
&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;body&gt; 
  &lt;p&gt;hugo says hello!&lt;/p&gt; 
&lt;/html&gt;
</code></pre><h4 id="live-reload-1">Live Reload</h4>
<p>Note: If you&rsquo;re running the server with the <code>--watch</code> option, you&rsquo;ll see different content in the file:</p>
<pre tabindex="0"><code>$ cat public/index.html 
&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;body&gt; 
  &lt;p&gt;hugo says hello!&lt;/p&gt; 
&lt;script&gt;document.write(&#39;&lt;script src=&#34;http://&#39; 
        + (location.host || &#39;localhost&#39;).split(&#39;:&#39;)[0] 
    + &#39;:1313/livereload.js?mindelay=10&#34;&gt;&lt;/&#39; 
        + &#39;script&gt;&#39;)&lt;/script&gt;&lt;/body&gt; 
&lt;/html&gt;
</code></pre><p>When you use <code>--watch</code>, the Live Reload script is added by Hugo. Look for live reload in the documentation to see what it does and how to disable it.</p>
<h3 id="build-a-dynamic-home-page">Build a &ldquo;Dynamic&rdquo; Home Page</h3>
<p>&ldquo;Dynamic home page?&rdquo; Hugo&rsquo;s a static web site generator, so this seems an odd thing to say. I mean let&rsquo;s have the home page automatically reflect the content in the site every time Hugo builds it. We&rsquo;ll use iteration in the template to do that.</p>
<h4 id="create-new-posts">Create New Posts</h4>
<p>Now that we have the home page generating static content, let&rsquo;s add some content to the site. We&rsquo;ll display these posts as a list on the home page and on their own page, too.</p>
<p>Hugo has a command to generate a skeleton post, just like it does for sites and themes.</p>
<pre tabindex="0"><code>$ hugo --verbose new post/first.md
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 attempting to create  post/first.md of post
INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/default.md
ERROR: 2014/09/29 Unable to Cast &lt;nil&gt; to map[string]interface{}

$ 
</code></pre><p>That wasn&rsquo;t very nice, was it?</p>
<p>The &ldquo;new&rdquo; command uses an archetype to create the post file. Hugo created an empty default archetype file, but that causes an error when there&rsquo;s a theme. For me, the workaround was to create an archetypes file specifically for the post type.</p>
<pre tabindex="0"><code>$ vi themes/zafta/archetypes/post.md
+++
Description = &#34;&#34;
Tags = []
Categories = []
+++
:wq

$ find themes/zafta/archetypes -type f | xargs ls -l
-rw-r--r--  1 quoha  staff   0 Sep 29 21:53 themes/zafta/archetypes/default.md
-rw-r--r--  1 quoha  staff  51 Sep 29 21:54 themes/zafta/archetypes/post.md

$ hugo --verbose new post/first.md
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 attempting to create  post/first.md of post
INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md
INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/first.md
/Users/quoha/Sites/zafta/content/post/first.md created

$ hugo --verbose new post/second.md
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 attempting to create  post/second.md of post
INFO: 2014/09/29 curpath: /Users/quoha/Sites/zafta/themes/zafta/archetypes/post.md
INFO: 2014/09/29 creating /Users/quoha/Sites/zafta/content/post/second.md
/Users/quoha/Sites/zafta/content/post/second.md created

$ ls -l content/post
total 16
-rw-r--r--  1 quoha  staff  104 Sep 29 21:54 first.md
-rw-r--r--  1 quoha  staff  105 Sep 29 21:57 second.md

$ cat content/post/first.md 
+++
Categories = []
Description = &#34;&#34;
Tags = []
date = &#34;2014-09-29T21:54:53-05:00&#34;
title = &#34;first&#34;

+++
my first post

$ cat content/post/second.md 
+++
Categories = []
Description = &#34;&#34;
Tags = []
date = &#34;2014-09-29T21:57:09-05:00&#34;
title = &#34;second&#34;

+++
my second post

$ 
</code></pre><p>Build the web site and then verify the results.</p>
<pre tabindex="0"><code>$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&#34;category&#34;:&#34;categories&#34;, &#34;tag&#34;:&#34;tags&#34;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
2 pages created 
0 tags created
0 categories created
in 4 ms
$
</code></pre><p>The output says that it created 2 pages. Those are our new posts:</p>
<pre tabindex="0"><code>$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  78 Sep 29 22:13 public/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/first/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:13 public/post/second/index.html
$
</code></pre><p>The new files are empty because because the templates used to generate the content are empty. The homepage doesn&rsquo;t show the new content, either. We have to update the templates to add the posts.</p>
<h3 id="list-and-single-templates">List and Single Templates</h3>
<p>In Hugo, we have three major kinds of templates. There&rsquo;s the home page template that we updated previously. It is used only by the home page. We also have &ldquo;single&rdquo; templates which are used to generate output for a single content file. We also have &ldquo;list&rdquo; templates that are used to group multiple pieces of content before generating output.</p>
<p>Generally speaking, list templates are named &ldquo;list.html&rdquo; and single templates are named &ldquo;single.html.&rdquo;</p>
<p>There are three other types of templates: partials, content views, and terms. We will not go into much detail on these.</p>
<h3 id="add-content-to-the-homepage">Add Content to the Homepage</h3>
<p>The home page will contain a list of posts. Let&rsquo;s update its template to add the posts that we just created. The logic in the template will run every time we build the site.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/index.html 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  {{ range first 10 .Data.Pages }}
    &lt;h1&gt;{{ .Title }}&lt;/h1&gt;
  {{ end }}
&lt;/body&gt;
&lt;/html&gt;
:wq

$
</code></pre><p>Hugo uses the Go template engine. That engine scans the template files for commands which are enclosed between &ldquo;{{&rdquo; and &ldquo;}}&rdquo;. In our template, the commands are:</p>
<ol>
<li>range</li>
<li>.Title</li>
<li>end</li>
</ol>
<p>The &ldquo;range&rdquo; command is an iterator. We&rsquo;re going to use it to go through the first ten pages. Every HTML file that Hugo creates is treated as a page, so looping through the list of pages will look at every file that will be created.</p>
<p>The &ldquo;.Title&rdquo; command prints the value of the &ldquo;title&rdquo; variable. Hugo pulls it from the front matter in the Markdown file.</p>
<p>The &ldquo;end&rdquo; command signals the end of the range iterator. The engine loops back to the top of the iteration when it finds &ldquo;end.&rdquo; Everything between the &ldquo;range&rdquo; and &ldquo;end&rdquo; is evaluated every time the engine goes through the iteration. In this file, that would cause the title from the first ten pages to be output as heading level one.</p>
<p>It&rsquo;s helpful to remember that some variables, like .Data, are created before any output files. Hugo loads every content file into the variable and then gives the template a chance to process before creating the HTML files.</p>
<p>Build the web site and then verify the results.</p>
<pre tabindex="0"><code>$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&#34;tag&#34;:&#34;tags&#34;, &#34;category&#34;:&#34;categories&#34;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
2 pages created 
0 tags created
0 categories created
in 4 ms
$ find public -type f -name &#39;*.html&#39; | xargs ls -l 
-rw-r--r--  1 quoha  staff  94 Sep 29 22:23 public/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/first/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/index.html
-rw-r--r--  1 quoha  staff   0 Sep 29 22:23 public/post/second/index.html
$ cat public/index.html 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  
    &lt;h1&gt;second&lt;/h1&gt;
  
    &lt;h1&gt;first&lt;/h1&gt;
  
&lt;/body&gt;
&lt;/html&gt;
$
</code></pre><p>Congratulations, the home page shows the title of the two posts. The posts themselves are still empty, but let&rsquo;s take a moment to appreciate what we&rsquo;ve done. Your template now generates output dynamically. Believe it or not, by inserting the range command inside of those curly braces, you&rsquo;ve learned everything you need to know to build a theme. All that&rsquo;s really left is understanding which template will be used to generate each content file and becoming familiar with the commands for the template engine.</p>
<p>And, if that were entirely true, this tutorial would be much shorter. There are a few things to know that will make creating a new template much easier. Don&rsquo;t worry, though, that&rsquo;s all to come.</p>
<h3 id="add-content-to-the-posts">Add Content to the Posts</h3>
<p>We&rsquo;re working with posts, which are in the content/post/ directory. That means that their section is &ldquo;post&rdquo; (and if we don&rsquo;t do something weird, their type is also &ldquo;post&rdquo;).</p>
<p>Hugo uses the section and type to find the template file for every piece of content. Hugo will first look for a template file that matches the section or type name. If it can&rsquo;t find one, then it will look in the _default/ directory. There are some twists that we&rsquo;ll cover when we get to categories and tags, but for now we can assume that Hugo will try post/single.html, then _default/single.html.</p>
<p>Now that we know the search rule, let&rsquo;s see what we actually have available:</p>
<pre tabindex="0"><code>$ find themes/zafta -name single.html | xargs ls -l
-rw-r--r--  1 quoha  staff  132 Sep 29 17:31 themes/zafta/layouts/_default/single.html
</code></pre><p>We could create a new template, post/single.html, or change the default. Since we don&rsquo;t know of any other content types, let&rsquo;s start with updating the default.</p>
<p>Remember, any content that we haven&rsquo;t created a template for will end up using this template. That can be good or bad. Bad because I know that we&rsquo;re going to be adding different types of content and we&rsquo;re going to end up undoing some of the changes we&rsquo;ve made. It&rsquo;s good because we&rsquo;ll be able to see immediate results. It&rsquo;s also good to start here because we can start to build the basic layout for the site. As we add more content types, we&rsquo;ll refactor this file and move logic around. Hugo makes that fairly painless, so we&rsquo;ll accept the cost and proceed.</p>
<p>Please see the Hugo documentation on template rendering for all the details on determining which template to use. And, as the docs mention, if you&rsquo;re building a single page application (SPA) web site, you can delete all of the other templates and work with just the default single page. That&rsquo;s a refreshing amount of joy right there.</p>
<h4 id="update-the-template-file">Update the Template File</h4>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/_default/single.html 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;{{ .Title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;
  {{ .Content }}
&lt;/body&gt;
&lt;/html&gt;
:wq

$
</code></pre><p>Build the web site and verify the results.</p>
<pre tabindex="0"><code>$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&#34;tag&#34;:&#34;tags&#34;, &#34;category&#34;:&#34;categories&#34;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
2 pages created 
0 tags created
0 categories created
in 4 ms

$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff   94 Sep 29 22:40 public/index.html
-rw-r--r--  1 quoha  staff  125 Sep 29 22:40 public/post/first/index.html
-rw-r--r--  1 quoha  staff    0 Sep 29 22:40 public/post/index.html
-rw-r--r--  1 quoha  staff  128 Sep 29 22:40 public/post/second/index.html

$ cat public/post/first/index.html 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;first&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;first&lt;/h1&gt;
  &lt;p&gt;my first post&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;

$ cat public/post/second/index.html 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;second&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;second&lt;/h1&gt;
  &lt;p&gt;my second post&lt;/p&gt;

&lt;/body&gt;
&lt;/html&gt;
$
</code></pre><p>Notice that the posts now have content. You can go to localhost:1313/post/first to verify.</p>
<h3 id="linking-to-content">Linking to Content</h3>
<p>The posts are on the home page. Let&rsquo;s add a link from there to the post. Since this is the home page, we&rsquo;ll update its template.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  {{ range first 10 .Data.Pages }}
    &lt;h1&gt;&lt;a href=&#34;{{ .Permalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/h1&gt;
  {{ end }}
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Build the web site and verify the results.</p>
<pre tabindex="0"><code>$ rm -rf public
$ hugo --verbose
INFO: 2014/09/29 Using config file: /Users/quoha/Sites/zafta/config.toml
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/themes/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 syncing from /Users/quoha/Sites/zafta/static/ to /Users/quoha/Sites/zafta/public/
INFO: 2014/09/29 found taxonomies: map[string]string{&#34;tag&#34;:&#34;tags&#34;, &#34;category&#34;:&#34;categories&#34;}
WARN: 2014/09/29 Unable to locate layout: [404.html theme/404.html]
0 draft content 
0 future content 
2 pages created 
0 tags created
0 categories created
in 4 ms

$ find public -type f -name &#39;*.html&#39; | xargs ls -l
-rw-r--r--  1 quoha  staff  149 Sep 29 22:44 public/index.html
-rw-r--r--  1 quoha  staff  125 Sep 29 22:44 public/post/first/index.html
-rw-r--r--  1 quoha  staff    0 Sep 29 22:44 public/post/index.html
-rw-r--r--  1 quoha  staff  128 Sep 29 22:44 public/post/second/index.html

$ cat public/index.html 
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  
    &lt;h1&gt;&lt;a href=&#34;/post/second/&#34;&gt;second&lt;/a&gt;&lt;/h1&gt;
  
    &lt;h1&gt;&lt;a href=&#34;/post/first/&#34;&gt;first&lt;/a&gt;&lt;/h1&gt;
  
&lt;/body&gt;
&lt;/html&gt;

$
</code></pre><h3 id="create-a-post-listing">Create a Post Listing</h3>
<p>We have the posts displaying on the home page and on their own page. We also have a file public/post/index.html that is empty. Let&rsquo;s make it show a list of all posts (not just the first ten).</p>
<p>We need to decide which template to update. This will be a listing, so it should be a list template. Let&rsquo;s take a quick look and see which list templates are available.</p>
<pre tabindex="0"><code>$ find themes/zafta -name list.html | xargs ls -l
-rw-r--r--  1 quoha  staff  0 Sep 29 17:31 themes/zafta/layouts/_default/list.html
</code></pre><p>As with the single post, we have to decide to update _default/list.html or create post/list.html. We still don&rsquo;t have multiple content types, so let&rsquo;s stay consistent and update the default list template.</p>
<h2 id="creating-top-level-pages">Creating Top Level Pages</h2>
<p>Let&rsquo;s add an &ldquo;about&rdquo; page and display it at the top level (as opposed to a sub-level like we did with posts).</p>
<p>The default in Hugo is to use the directory structure of the content/ directory to guide the location of the generated html in the public/ directory. Let&rsquo;s verify that by creating an &ldquo;about&rdquo; page at the top level:</p>
<pre tabindex="0"><code>$ vi content/about.md 
+++
title = &#34;about&#34;
description = &#34;about this site&#34;
date = &#34;2014-09-27&#34;
slug = &#34;about time&#34;
+++

## about us

i&#39;m speechless
:wq
</code></pre><p>Generate the web site and verify the results.</p>
<pre tabindex="0"><code>$ find public -name &#39;*.html&#39; | xargs ls -l
-rw-rw-r--  1 mdhender  staff   334 Sep 27 15:08 public/about-time/index.html
-rw-rw-r--  1 mdhender  staff   527 Sep 27 15:08 public/index.html
-rw-rw-r--  1 mdhender  staff   358 Sep 27 15:08 public/post/first-post/index.html
-rw-rw-r--  1 mdhender  staff     0 Sep 27 15:08 public/post/index.html
-rw-rw-r--  1 mdhender  staff   342 Sep 27 15:08 public/post/second-post/index.html
</code></pre><p>Notice that the page wasn&rsquo;t created at the top level. It was created in a sub-directory named &lsquo;about-time/&rsquo;. That name came from our slug. Hugo will use the slug to name the generated content. It&rsquo;s a reasonable default, by the way, but we can learn a few things by fighting it for this file.</p>
<p>One other thing. Take a look at the home page.</p>
<pre tabindex="0"><code>$ cat public/index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
    &lt;h1&gt;&lt;a href=&#34;http://localhost:1313/post/theme/&#34;&gt;creating a new theme&lt;/a&gt;&lt;/h1&gt;
    &lt;h1&gt;&lt;a href=&#34;http://localhost:1313/about-time/&#34;&gt;about&lt;/a&gt;&lt;/h1&gt;
    &lt;h1&gt;&lt;a href=&#34;http://localhost:1313/post/second-post/&#34;&gt;second&lt;/a&gt;&lt;/h1&gt;
    &lt;h1&gt;&lt;a href=&#34;http://localhost:1313/post/first-post/&#34;&gt;first&lt;/a&gt;&lt;/h1&gt;
&lt;script&gt;document.write(&#39;&lt;script src=&#34;http://&#39;
        + (location.host || &#39;localhost&#39;).split(&#39;:&#39;)[0]
		+ &#39;:1313/livereload.js?mindelay=10&#34;&gt;&lt;/&#39;
        + &#39;script&gt;&#39;)&lt;/script&gt;&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Notice that the &ldquo;about&rdquo; link is listed with the posts? That&rsquo;s not desirable, so let&rsquo;s change that first.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/index.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;body&gt;
  &lt;h1&gt;posts&lt;/h1&gt;
  {{ range first 10 .Data.Pages }}
    {{ if eq .Type &#34;post&#34;}}
      &lt;h2&gt;&lt;a href=&#34;{{ .Permalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/h2&gt;
    {{ end }}
  {{ end }}

  &lt;h1&gt;pages&lt;/h1&gt;
  {{ range .Data.Pages }}
    {{ if eq .Type &#34;page&#34; }}
      &lt;h2&gt;&lt;a href=&#34;{{ .Permalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/h2&gt;
    {{ end }}
  {{ end }}
&lt;/body&gt;
&lt;/html&gt;
:wq
</code></pre><p>Generate the web site and verify the results. The home page has two sections, posts and pages, and each section has the right set of headings and links in it.</p>
<p>But, that about page still renders to about-time/index.html.</p>
<pre tabindex="0"><code>$ find public -name &#39;*.html&#39; | xargs ls -l
-rw-rw-r--  1 mdhender  staff    334 Sep 27 15:33 public/about-time/index.html
-rw-rw-r--  1 mdhender  staff    645 Sep 27 15:33 public/index.html
-rw-rw-r--  1 mdhender  staff    358 Sep 27 15:33 public/post/first-post/index.html
-rw-rw-r--  1 mdhender  staff      0 Sep 27 15:33 public/post/index.html
-rw-rw-r--  1 mdhender  staff    342 Sep 27 15:33 public/post/second-post/index.html
</code></pre><p>Knowing that hugo is using the slug to generate the file name, the simplest solution is to change the slug. Let&rsquo;s do it the hard way and change the permalink in the configuration file.</p>
<pre tabindex="0"><code>$ vi config.toml
[permalinks]
	page = &#34;/:title/&#34;
	about = &#34;/:filename/&#34;
</code></pre><p>Generate the web site and verify that this didn&rsquo;t work. Hugo lets &ldquo;slug&rdquo; or &ldquo;URL&rdquo; override the permalinks setting in the configuration file. Go ahead and comment out the slug in content/about.md, then generate the web site to get it to be created in the right place.</p>
<h2 id="sharing-templates">Sharing Templates</h2>
<p>If you&rsquo;ve been following along, you probably noticed that posts have titles in the browser and the home page doesn&rsquo;t. That&rsquo;s because we didn&rsquo;t put the title in the home page&rsquo;s template (layouts/index.html). That&rsquo;s an easy thing to do, but let&rsquo;s look at a different option.</p>
<p>We can put the common bits into a shared template that&rsquo;s stored in the themes/zafta/layouts/partials/ directory.</p>
<h3 id="create-the-header-and-footer-partials">Create the Header and Footer Partials</h3>
<p>In Hugo, a partial is a sugar-coated template. Normally a template reference has a path specified. Partials are different. Hugo searches for them along a TODO defined search path. This makes it easier for end-users to override the theme&rsquo;s presentation.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/partials/header.html
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
	&lt;title&gt;{{ .Title }}&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
:wq

$ vi themes/zafta/layouts/partials/footer.html
&lt;/body&gt;
&lt;/html&gt;
:wq
</code></pre><h3 id="update-the-home-page-template-to-use-the-partials">Update the Home Page Template to Use the Partials</h3>
<p>The most noticeable difference between a template call and a partials call is the lack of path:</p>
<pre tabindex="0"><code>{{ template &#34;theme/partials/header.html&#34; . }}
</code></pre><p>versus</p>
<pre tabindex="0"><code>{{ partial &#34;header.html&#34; . }}
</code></pre><p>Both pass in the context.</p>
<p>Let&rsquo;s change the home page template to use these new partials.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/index.html
{{ partial &#34;header.html&#34; . }}

  &lt;h1&gt;posts&lt;/h1&gt;
  {{ range first 10 .Data.Pages }}
    {{ if eq .Type &#34;post&#34;}}
      &lt;h2&gt;&lt;a href=&#34;{{ .Permalink }}&#34;&gt;{{ .Title }}&lt;/a&gt;&lt;/h2&gt;
    {{ end }}
  {{ end }}

  &lt;h1&gt;pages&lt;/h1&gt;
  {{ range .Data.Pages }}
    {{ if or (eq .Type &#34;page&#34;) (eq .Type &#34;about&#34;) }}
      &lt;h2&gt;&lt;a href=&#34;{{ .Permalink }}&#34;&gt;{{ .Type }} - {{ .Title }} - {{ .RelPermalink }}&lt;/a&gt;&lt;/h2&gt;
    {{ end }}
  {{ end }}

{{ partial &#34;footer.html&#34; . }}
:wq
</code></pre><p>Generate the web site and verify the results. The title on the home page is now &ldquo;your title here&rdquo;, which comes from the &ldquo;title&rdquo; variable in the config.toml file.</p>
<h3 id="update-the-default-single-template-to-use-the-partials">Update the Default Single Template to Use the Partials</h3>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/_default/single.html
{{ partial &#34;header.html&#34; . }}

  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;
  {{ .Content }}

{{ partial &#34;footer.html&#34; . }}
:wq
</code></pre><p>Generate the web site and verify the results. The title on the posts and the about page should both reflect the value in the markdown file.</p>
<h2 id="add-date-published-to-posts">Add “Date Published” to Posts</h2>
<p>It&rsquo;s common to have posts display the date that they were written or published, so let&rsquo;s add that. The front matter of our posts has a variable named &ldquo;date.&rdquo; It&rsquo;s usually the date the content was created, but let&rsquo;s pretend that&rsquo;s the value we want to display.</p>
<h3 id="add-date-published-to-the-template">Add “Date Published” to the Template</h3>
<p>We&rsquo;ll start by updating the template used to render the posts. The template code will look like:</p>
<pre tabindex="0"><code>{{ .Date.Format &#34;Mon, Jan 2, 2006&#34; }}
</code></pre><p>Posts use the default single template, so we&rsquo;ll change that file.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/_default/single.html
{{ partial &#34;header.html&#34; . }}

  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;
  &lt;h2&gt;{{ .Date.Format &#34;Mon, Jan 2, 2006&#34; }}&lt;/h2&gt;
  {{ .Content }}

{{ partial &#34;footer.html&#34; . }}
:wq
</code></pre><p>Generate the web site and verify the results. The posts now have the date displayed in them. There&rsquo;s a problem, though. The &ldquo;about&rdquo; page also has the date displayed.</p>
<p>As usual, there are a couple of ways to make the date display only on posts. We could do an &ldquo;if&rdquo; statement like we did on the home page. Another way would be to create a separate template for posts.</p>
<p>The &ldquo;if&rdquo; solution works for sites that have just a couple of content types. It aligns with the principle of &ldquo;code for today,&rdquo; too.</p>
<p>Let&rsquo;s assume, though, that we&rsquo;ve made our site so complex that we feel we have to create a new template type. In Hugo-speak, we&rsquo;re going to create a section template.</p>
<p>Let&rsquo;s restore the default single template before we forget.</p>
<pre tabindex="0"><code>$ mkdir themes/zafta/layouts/post
$ vi themes/zafta/layouts/_default/single.html
{{ partial &#34;header.html&#34; . }}

  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;
  {{ .Content }}

{{ partial &#34;footer.html&#34; . }}
:wq
</code></pre><p>Now we&rsquo;ll update the post&rsquo;s version of the single template. If you remember Hugo&rsquo;s rules, the template engine will use this version over the default.</p>
<pre tabindex="0"><code>$ vi themes/zafta/layouts/post/single.html
{{ partial &#34;header.html&#34; . }}

  &lt;h1&gt;{{ .Title }}&lt;/h1&gt;
  &lt;h2&gt;{{ .Date.Format &#34;Mon, Jan 2, 2006&#34; }}&lt;/h2&gt;
  {{ .Content }}

{{ partial &#34;footer.html&#34; . }}
:wq
</code></pre><p>Note that we removed the date logic from the default template and put it in the post template. Generate the web site and verify the results. Posts have dates and the about page doesn&rsquo;t.</p>
<h3 id="dont-repeat-yourself">Don&rsquo;t Repeat Yourself</h3>
<p>DRY is a good design goal and Hugo does a great job supporting it. Part of the art of a good template is knowing when to add a new template and when to update an existing one. While you&rsquo;re figuring that out, accept that you&rsquo;ll be doing some refactoring. Hugo makes that easy and fast, so it&rsquo;s okay to delay splitting up a template.</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="migrate-to-hugo-from-jekyll">
                                    <h2 class="major">Migrate to Hugo from Jekyll</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h2 id="move-static-content-to-static">Move static content to <code>static</code></h2>
<p>Jekyll has a rule that any directory not starting with <code>_</code> will be copied as-is to the <code>_site</code> output. Hugo keeps all static content under <code>static</code>. You should therefore move it all there.
With Jekyll, something that looked like</p>
<pre><code>▾ &lt;root&gt;/
    ▾ images/
        logo.png
</code></pre>
<p>should become</p>
<pre><code>▾ &lt;root&gt;/
    ▾ static/
        ▾ images/
            logo.png
</code></pre>
<p>Additionally, you&rsquo;ll want any files that should reside at the root (such as <code>CNAME</code>) to be moved to <code>static</code>.</p>
<h2 id="create-your-hugo-configuration-file">Create your Hugo configuration file</h2>
<p>Hugo can read your configuration as JSON, YAML or TOML. Hugo supports parameters custom configuration too. Refer to the <a href="/overview/configuration/">Hugo configuration documentation</a> for details.</p>
<h2 id="set-your-configuration-publish-folder-to-_site">Set your configuration publish folder to <code>_site</code></h2>
<p>The default is for Jekyll to publish to <code>_site</code> and for Hugo to publish to <code>public</code>. If, like me, you have <a href="http://blog.blindgaenger.net/generate_github_pages_in_a_submodule.html"><code>_site</code> mapped to a git submodule on the <code>gh-pages</code> branch</a>, you&rsquo;ll want to do one of two alternatives:</p>
<ol>
<li>
<p>Change your submodule to point to map <code>gh-pages</code> to public instead of <code>_site</code> (recommended).</p>
<pre><code> git submodule deinit _site
 git rm _site
 git submodule add -b gh-pages git@github.com:your-username/your-repo.git public
</code></pre>
</li>
<li>
<p>Or, change the Hugo configuration to use <code>_site</code> instead of <code>public</code>.</p>
<pre><code> {
     ..
     &quot;publishdir&quot;: &quot;_site&quot;,
     ..
 }
</code></pre>
</li>
</ol>
<h2 id="convert-jekyll-templates-to-hugo-templates">Convert Jekyll templates to Hugo templates</h2>
<p>That&rsquo;s the bulk of the work right here. The documentation is your friend. You should refer to <a href="http://jekyllrb.com/docs/templates/">Jekyll&rsquo;s template documentation</a> if you need to refresh your memory on how you built your blog and <a href="/layout/templates/">Hugo&rsquo;s template</a> to learn Hugo&rsquo;s way.</p>
<p>As a single reference data point, converting my templates for <a href="http://heyitsalex.net/">heyitsalex.net</a> took me no more than a few hours.</p>
<h2 id="convert-jekyll-plugins-to-hugo-shortcodes">Convert Jekyll plugins to Hugo shortcodes</h2>
<p>Jekyll has <a href="http://jekyllrb.com/docs/plugins/">plugins</a>; Hugo has <a href="/doc/shortcodes/">shortcodes</a>. It&rsquo;s fairly trivial to do a port.</p>
<h3 id="implementation">Implementation</h3>
<p>As an example, I was using a custom <a href="https://github.com/alexandre-normand/alexandre-normand/blob/74bb12036a71334fdb7dba84e073382fc06908ec/_plugins/image_tag.rb"><code>image_tag</code></a> plugin to generate figures with caption when running Jekyll. As I read about shortcodes, I found Hugo had a nice built-in shortcode that does exactly the same thing.</p>
<p>Jekyll&rsquo;s plugin:</p>
<pre><code>module Jekyll
  class ImageTag &lt; Liquid::Tag
    @url = nil
    @caption = nil
    @class = nil
    @link = nil
    // Patterns
    IMAGE_URL_WITH_CLASS_AND_CAPTION =
    IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK = /(\w+)(\s+)((https?:\/\/|\/)(\S+))(\s+)&quot;(.*?)&quot;(\s+)-&gt;((https?:\/\/|\/)(\S+))(\s*)/i
    IMAGE_URL_WITH_CAPTION = /((https?:\/\/|\/)(\S+))(\s+)&quot;(.*?)&quot;/i
    IMAGE_URL_WITH_CLASS = /(\w+)(\s+)((https?:\/\/|\/)(\S+))/i
    IMAGE_URL = /((https?:\/\/|\/)(\S+))/i
    def initialize(tag_name, markup, tokens)
      super
      if markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION_AND_LINK
        @class   = $1
        @url     = $3
        @caption = $7
        @link = $9
      elsif markup =~ IMAGE_URL_WITH_CLASS_AND_CAPTION
        @class   = $1
        @url     = $3
        @caption = $7
      elsif markup =~ IMAGE_URL_WITH_CAPTION
        @url     = $1
        @caption = $5
      elsif markup =~ IMAGE_URL_WITH_CLASS
        @class = $1
        @url   = $3
      elsif markup =~ IMAGE_URL
        @url = $1
      end
    end
    def render(context)
      if @class
        source = &quot;&lt;figure class='#{@class}'&gt;&quot;
      else
        source = &quot;&lt;figure&gt;&quot;
      end
      if @link
        source += &quot;&lt;a href=\&quot;#{@link}\&quot;&gt;&quot;
      end
      source += &quot;&lt;img src=\&quot;#{@url}\&quot;&gt;&quot;
      if @link
        source += &quot;&lt;/a&gt;&quot;
      end
      source += &quot;&lt;figcaption&gt;#{@caption}&lt;/figcaption&gt;&quot; if @caption
      source += &quot;&lt;/figure&gt;&quot;
      source
    end
  end
end
Liquid::Template.register_tag('image', Jekyll::ImageTag)
</code></pre>
<p>is written as this Hugo shortcode:</p>
<pre><code>&lt;!-- image --&gt;
&lt;figure {{ with .Get &quot;class&quot; }}class=&quot;{{.}}&quot;{{ end }}&gt;
    {{ with .Get &quot;link&quot;}}&lt;a href=&quot;{{.}}&quot;&gt;{{ end }}
        &lt;img src=&quot;{{ .Get &quot;src&quot; }}&quot; {{ if or (.Get &quot;alt&quot;) (.Get &quot;caption&quot;) }}alt=&quot;{{ with .Get &quot;alt&quot;}}{{.}}{{else}}{{ .Get &quot;caption&quot; }}{{ end }}&quot;{{ end }} /&gt;
    {{ if .Get &quot;link&quot;}}&lt;/a&gt;{{ end }}
    {{ if or (or (.Get &quot;title&quot;) (.Get &quot;caption&quot;)) (.Get &quot;attr&quot;)}}
    &lt;figcaption&gt;{{ if isset .Params &quot;title&quot; }}
        {{ .Get &quot;title&quot; }}{{ end }}
        {{ if or (.Get &quot;caption&quot;) (.Get &quot;attr&quot;)}}&lt;p&gt;
        {{ .Get &quot;caption&quot; }}
        {{ with .Get &quot;attrlink&quot;}}&lt;a href=&quot;{{.}}&quot;&gt; {{ end }}
            {{ .Get &quot;attr&quot; }}
        {{ if .Get &quot;attrlink&quot;}}&lt;/a&gt; {{ end }}
        &lt;/p&gt; {{ end }}
    &lt;/figcaption&gt;
    {{ end }}
&lt;/figure&gt;
&lt;!-- image --&gt;
</code></pre>
<h3 id="usage">Usage</h3>
<p>I simply changed:</p>
<pre><code>{% image full http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg &quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were &quot;having fun&quot; and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.&quot; -&gt;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/ %}
</code></pre>
<p>to this (this example uses a slightly extended version named <code>fig</code>, different than the built-in <code>figure</code>):</p>
<pre><code>{{% fig class=&quot;full&quot; src=&quot;http://farm5.staticflickr.com/4136/4829260124_57712e570a_o_d.jpg&quot; title=&quot;One of my favorite touristy-type photos. I secretly waited for the good light while we were having fun and took this. Only regret: a stupid pole in the top-left corner of the frame I had to clumsily get rid of at post-processing.&quot; link=&quot;http://www.flickr.com/photos/alexnormand/4829260124/in/set-72157624547713078/&quot; %}}
</code></pre>
<p>As a bonus, the shortcode named parameters are, arguably, more readable.</p>
<h2 id="finishing-touches">Finishing touches</h2>
<h3 id="fix-content">Fix content</h3>
<p>Depending on the amount of customization that was done with each post with Jekyll, this step will require more or less effort. There are no hard and fast rules here except that <code>hugo server --watch</code> is your friend. Test your changes and fix errors as needed.</p>
<h3 id="clean-up">Clean up</h3>
<p>You&rsquo;ll want to remove the Jekyll configuration at this point. If you have anything else that isn&rsquo;t used, delete it.</p>
<h2 id="a-practical-example-in-a-diff">A practical example in a diff</h2>
<p><a href="http://heyitsalex.net/">Hey, it&rsquo;s Alex</a> was migrated in less than a <em>father-with-kids day</em> from Jekyll to Hugo. You can see all the changes (and screw-ups) by looking at this <a href="https://github.com/alexandre-normand/alexandre-normand/compare/869d69435bd2665c3fbf5b5c78d4c22759d7613a...b7f6605b1265e83b4b81495423294208cc74d610">diff</a>.</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="hugo-template-primer">
                                    <h2 class="major">(Hu)go Template Primer</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <p>Hugo uses the excellent <a href="https://golang.org/">Go</a> <a href="https://golang.org/pkg/html/template/">html/template</a> library for
its template engine. It is an extremely lightweight engine that provides a very
small amount of logic. In our experience that it is just the right amount of
logic to be able to create a good static website. If you have used other
template systems from different languages or frameworks you will find a lot of
similarities in Go templates.</p>
<p>This document is a brief primer on using Go templates. The <a href="https://golang.org/pkg/html/template/">Go docs</a>
provide more details.</p>
<h2 id="introduction-to-go-templates">Introduction to Go Templates</h2>
<p>Go templates provide an extremely simple template language. It adheres to the
belief that only the most basic of logic belongs in the template or view layer.
One consequence of this simplicity is that Go templates parse very quickly.</p>
<p>A unique characteristic of Go templates is they are content aware. Variables and
content will be sanitized depending on the context of where they are used. More
details can be found in the <a href="https://golang.org/pkg/html/template/">Go docs</a>.</p>
<h2 id="basic-syntax">Basic Syntax</h2>
<p>Golang templates are HTML files with the addition of variables and
functions.</p>
<p><strong>Go variables and functions are accessible within {{ }}</strong></p>
<p>Accessing a predefined variable &ldquo;foo&rdquo;:</p>
<pre><code>{{ foo }}
</code></pre>
<p><strong>Parameters are separated using spaces</strong></p>
<p>Calling the add function with input of 1, 2:</p>
<pre><code>{{ add 1 2 }}
</code></pre>
<p><strong>Methods and fields are accessed via dot notation</strong></p>
<p>Accessing the Page Parameter &ldquo;bar&rdquo;</p>
<pre><code>{{ .Params.bar }}
</code></pre>
<p><strong>Parentheses can be used to group items together</strong></p>
<pre><code>{{ if or (isset .Params &quot;alt&quot;) (isset .Params &quot;caption&quot;) }} Caption {{ end }}
</code></pre>
<h2 id="variables">Variables</h2>
<p>Each Go template has a struct (object) made available to it. In hugo each
template is passed either a page or a node struct depending on which type of
page you are rendering. More details are available on the
<a href="/layout/variables">variables</a> page.</p>
<p>A variable is accessed by referencing the variable name.</p>
<pre><code>&lt;title&gt;{{ .Title }}&lt;/title&gt;
</code></pre>
<p>Variables can also be defined and referenced.</p>
<pre><code>{{ $address := &quot;123 Main St.&quot;}}
{{ $address }}
</code></pre>
<h2 id="functions">Functions</h2>
<p>Go template ship with a few functions which provide basic functionality. The Go
template system also provides a mechanism for applications to extend the
available functions with their own. <a href="/layout/functions">Hugo template
functions</a> provide some additional functionality we believe
are useful for building websites. Functions are called by using their name
followed by the required parameters separated by spaces. Template
functions cannot be added without recompiling hugo.</p>
<p><strong>Example:</strong></p>
<pre><code>{{ add 1 2 }}
</code></pre>
<h2 id="includes">Includes</h2>
<p>When including another template you will pass to it the data it will be
able to access. To pass along the current context please remember to
include a trailing dot. The templates location will always be starting at
the /layout/ directory within Hugo.</p>
<p><strong>Example:</strong></p>
<pre><code>{{ template &quot;chrome/header.html&quot; . }}
</code></pre>
<h2 id="logic">Logic</h2>
<p>Go templates provide the most basic iteration and conditional logic.</p>
<h3 id="iteration">Iteration</h3>
<p>Just like in Go, the Go templates make heavy use of range to iterate over
a map, array or slice. The following are different examples of how to use
range.</p>
<p><strong>Example 1: Using Context</strong></p>
<pre><code>{{ range array }}
    {{ . }}
{{ end }}
</code></pre>
<p><strong>Example 2: Declaring value variable name</strong></p>
<pre><code>{{range $element := array}}
    {{ $element }}
{{ end }}
</code></pre>
<p><strong>Example 2: Declaring key and value variable name</strong></p>
<pre><code>{{range $index, $element := array}}
    {{ $index }}
    {{ $element }}
{{ end }}
</code></pre>
<h3 id="conditionals">Conditionals</h3>
<p>If, else, with, or, &amp; and provide the framework for handling conditional
logic in Go Templates. Like range, each statement is closed with <code>end</code>.</p>
<p>Go Templates treat the following values as false:</p>
<ul>
<li>false</li>
<li>0</li>
<li>any array, slice, map, or string of length zero</li>
</ul>
<p><strong>Example 1: If</strong></p>
<pre><code>{{ if isset .Params &quot;title&quot; }}&lt;h4&gt;{{ index .Params &quot;title&quot; }}&lt;/h4&gt;{{ end }}
</code></pre>
<p><strong>Example 2: If -&gt; Else</strong></p>
<pre><code>{{ if isset .Params &quot;alt&quot; }}
    {{ index .Params &quot;alt&quot; }}
{{else}}
    {{ index .Params &quot;caption&quot; }}
{{ end }}
</code></pre>
<p><strong>Example 3: And &amp; Or</strong></p>
<pre><code>{{ if and (or (isset .Params &quot;title&quot;) (isset .Params &quot;caption&quot;)) (isset .Params &quot;attr&quot;)}}
</code></pre>
<p><strong>Example 4: With</strong></p>
<p>An alternative way of writing &ldquo;if&rdquo; and then referencing the same value
is to use &ldquo;with&rdquo; instead. With rebinds the context <code>.</code> within its scope,
and skips the block if the variable is absent.</p>
<p>The first example above could be simplified as:</p>
<pre><code>{{ with .Params.title }}&lt;h4&gt;{{ . }}&lt;/h4&gt;{{ end }}
</code></pre>
<p><strong>Example 5: If -&gt; Else If</strong></p>
<pre><code>{{ if isset .Params &quot;alt&quot; }}
    {{ index .Params &quot;alt&quot; }}
{{ else if isset .Params &quot;caption&quot; }}
    {{ index .Params &quot;caption&quot; }}
{{ end }}
</code></pre>
<h2 id="pipes">Pipes</h2>
<p>One of the most powerful components of Go templates is the ability to
stack actions one after another. This is done by using pipes. Borrowed
from unix pipes, the concept is simple, each pipeline&rsquo;s output becomes the
input of the following pipe.</p>
<p>Because of the very simple syntax of Go templates, the pipe is essential
to being able to chain together function calls. One limitation of the
pipes is that they only can work with a single value and that value
becomes the last parameter of the next pipeline.</p>
<p>A few simple examples should help convey how to use the pipe.</p>
<p><strong>Example 1 :</strong></p>
<pre><code>{{ if eq 1 1 }} Same {{ end }}
</code></pre>
<p>is the same as</p>
<pre><code>{{ eq 1 1 | if }} Same {{ end }}
</code></pre>
<p>It does look odd to place the if at the end, but it does provide a good
illustration of how to use the pipes.</p>
<p><strong>Example 2 :</strong></p>
<pre><code>{{ index .Params &quot;disqus_url&quot; | html }}
</code></pre>
<p>Access the page parameter called &ldquo;disqus_url&rdquo; and escape the HTML.</p>
<p><strong>Example 3 :</strong></p>
<pre><code>{{ if or (or (isset .Params &quot;title&quot;) (isset .Params &quot;caption&quot;)) (isset .Params &quot;attr&quot;)}}
Stuff Here
{{ end }}
</code></pre>
<p>Could be rewritten as</p>
<pre><code>{{  isset .Params &quot;caption&quot; | or isset .Params &quot;title&quot; | or isset .Params &quot;attr&quot; | if }}
Stuff Here
{{ end }}
</code></pre>
<h2 id="context-aka-the-dot">Context (aka. the dot)</h2>
<p>The most easily overlooked concept to understand about Go templates is that {{ . }}
always refers to the current context. In the top level of your template this
will be the data set made available to it. Inside of a iteration it will have
the value of the current item. When inside of a loop the context has changed. .
will no longer refer to the data available to the entire page. If you need to
access this from within the loop you will likely want to set it to a variable
instead of depending on the context.</p>
<p><strong>Example:</strong></p>
<pre><code>  {{ $title := .Site.Title }}
  {{ range .Params.tags }}
    &lt;li&gt; &lt;a href=&quot;{{ $baseurl }}/tags/{{ . | urlize }}&quot;&gt;{{ . }}&lt;/a&gt; - {{ $title }} &lt;/li&gt;
  {{ end }}
</code></pre>
<p>Notice how once we have entered the loop the value of {{ . }} has changed. We
have defined a variable outside of the loop so we have access to it from within
the loop.</p>
<h1 id="hugo-parameters">Hugo Parameters</h1>
<p>Hugo provides the option of passing values to the template language
through the site configuration (for sitewide values), or through the meta
data of each specific piece of content. You can define any values of any
type (supported by your front matter/config format) and use them however
you want to inside of your templates.</p>
<h2 id="using-content-page-parameters">Using Content (page) Parameters</h2>
<p>In each piece of content you can provide variables to be used by the
templates. This happens in the <a href="/content/front-matter">front matter</a>.</p>
<p>An example of this is used in this documentation site. Most of the pages
benefit from having the table of contents provided. Sometimes the TOC just
doesn&rsquo;t make a lot of sense. We&rsquo;ve defined a variable in our front matter
of some pages to turn off the TOC from being displayed.</p>
<p>Here is the example front matter:</p>
<pre tabindex="0"><code>---
title: &#34;Permalinks&#34;
date: &#34;2013-11-18&#34;
aliases:
  - &#34;/doc/permalinks/&#34;
groups: [&#34;extras&#34;]
groups_weight: 30
notoc: true
---
</code></pre><p>Here is the corresponding code inside of the template:</p>
<pre><code>  {{ if not .Params.notoc }}
    &lt;div id=&quot;toc&quot; class=&quot;well col-md-4 col-sm-6&quot;&gt;
    {{ .TableOfContents }}
    &lt;/div&gt;
  {{ end }}
</code></pre>
<h2 id="using-site-config-parameters">Using Site (config) Parameters</h2>
<p>In your top-level configuration file (eg, <code>config.yaml</code>) you can define site
parameters, which are values which will be available to you in chrome.</p>
<p>For instance, you might declare:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-yaml" data-lang="yaml"><span style="display:flex;"><span><span style="color:#f92672">params</span>:
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">CopyrightHTML</span>: <span style="color:#e6db74">&#34;Copyright &amp;#xA9; 2013 John Doe. All Rights Reserved.&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">TwitterUser</span>: <span style="color:#e6db74">&#34;spf13&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">SidebarRecentLimit</span>: <span style="color:#ae81ff">5</span>
</span></span></code></pre></div><p>Within a footer layout, you might then declare a <code>&lt;footer&gt;</code> which is only
provided if the <code>CopyrightHTML</code> parameter is provided, and if it is given,
you would declare it to be HTML-safe, so that the HTML entity is not escaped
again.  This would let you easily update just your top-level config file each
January 1st, instead of hunting through your templates.</p>
<pre tabindex="0"><code>{{if .Site.Params.CopyrightHTML}}&lt;footer&gt;
&lt;div class=&#34;text-center&#34;&gt;{{.Site.Params.CopyrightHTML | safeHtml}}&lt;/div&gt;
&lt;/footer&gt;{{end}}
</code></pre><p>An alternative way of writing the &ldquo;if&rdquo; and then referencing the same value
is to use &ldquo;with&rdquo; instead. With rebinds the context <code>.</code> within its scope,
and skips the block if the variable is absent:</p>
<pre tabindex="0"><code>{{with .Site.Params.TwitterUser}}&lt;span class=&#34;twitter&#34;&gt;
&lt;a href=&#34;https://twitter.com/{{.}}&#34; rel=&#34;author&#34;&gt;
&lt;img src=&#34;/images/twitter.png&#34; width=&#34;48&#34; height=&#34;48&#34; title=&#34;Twitter: {{.}}&#34;
 alt=&#34;Twitter&#34;&gt;&lt;/a&gt;
&lt;/span&gt;{{end}}
</code></pre><p>Finally, if you want to pull &ldquo;magic constants&rdquo; out of your layouts, you can do
so, such as in this example:</p>
<pre tabindex="0"><code>&lt;nav class=&#34;recent&#34;&gt;
  &lt;h1&gt;Recent Posts&lt;/h1&gt;
  &lt;ul&gt;{{range first .Site.Params.SidebarRecentLimit .Site.Recent}}
    &lt;li&gt;&lt;a href=&#34;{{.RelPermalink}}&#34;&gt;{{.Title}}&lt;/a&gt;&lt;/li&gt;
  {{end}}&lt;/ul&gt;
&lt;/nav&gt;
</code></pre>
                                </article>
                            
                        
                    
                        
                            
                                <article id="getting-started-with-hugo">
                                    <h2 class="major">Getting Started with Hugo</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h2 id="step-1-install-hugo">Step 1. Install Hugo</h2>
<p>Go to <a href="https://github.com/spf13/hugo/releases">Hugo releases</a> and download the
appropriate version for your OS and architecture.</p>
<p>Save it somewhere specific as we will be using it in the next step.</p>
<p>More complete instructions are available at <a href="https://gohugo.io/getting-started/installing/">Install Hugo</a></p>
<h2 id="step-2-build-the-docs">Step 2. Build the Docs</h2>
<p>Hugo has its own example site which happens to also be the documentation site
you are reading right now.</p>
<p>Follow the following steps:</p>
<ol>
<li>Clone the <a href="http://github.com/spf13/hugo">Hugo repository</a></li>
<li>Go into the repo</li>
<li>Run hugo in server mode and build the docs</li>
<li>Open your browser to http://localhost:1313</li>
</ol>
<p>Corresponding pseudo commands:</p>
<pre><code>git clone https://github.com/spf13/hugo
cd hugo
/path/to/where/you/installed/hugo server --source=./docs
&gt; 29 pages created
&gt; 0 tags index created
&gt; in 27 ms
&gt; Web Server is available at http://localhost:1313
&gt; Press ctrl+c to stop
</code></pre>
<p>Once you&rsquo;ve gotten here, follow along the rest of this page on your local build.</p>
<h2 id="step-3-change-the-docs-site">Step 3. Change the docs site</h2>
<p>Stop the Hugo process by hitting Ctrl+C.</p>
<p>Now we are going to run hugo again, but this time with hugo in watch mode.</p>
<pre><code>/path/to/hugo/from/step/1/hugo server --source=./docs --watch
&gt; 29 pages created
&gt; 0 tags index created
&gt; in 27 ms
&gt; Web Server is available at http://localhost:1313
&gt; Watching for changes in /Users/spf13/Code/hugo/docs/content
&gt; Press ctrl+c to stop
</code></pre>
<p>Open your <a href="http://vim.spf13.com">favorite editor</a> and change one of the source
content pages. How about changing this very file to <em>fix the typo</em>. How about changing this very file to <em>fix the typo</em>.</p>
<p>Content files are found in <code>docs/content/</code>. Unless otherwise specified, files
are located at the same relative location as the url, in our case
<code>docs/content/overview/quickstart.md</code>.</p>
<p>Change and save this file.. Notice what happened in your terminal.</p>
<pre><code>&gt; Change detected, rebuilding site

&gt; 29 pages created
&gt; 0 tags index created
&gt; in 26 ms
</code></pre>
<p>Refresh the browser and observe that the typo is now fixed.</p>
<p>Notice how quick that was. Try to refresh the site before it&rsquo;s finished building. I double dare you.
Having nearly instant feedback enables you to have your creativity flow without waiting for long builds.</p>
<h2 id="step-4-have-fun">Step 4. Have fun</h2>
<p>The best way to learn something is to play with it.</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="archlinux-tes9999999">
                                    <h2 class="major">ArchLinux Tes9999999</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="subject">Subject</h1>
<pre><code>TestTest 12312312332121123123312321
</code></pre>

                                </article>
                            
                        
                    
                        
                            
                                <article id="archlinux-test">
                                    <h2 class="major">ArchLinux Test</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="subject">Subject</h1>
<p>1312312312312321 TestTest</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="archlinux-test123">
                                    <h2 class="major">ArchLinux Test123</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="subject">Subject</h1>
<p>1312312312312321 TestTest 12312312332121123123312321</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="qxjjaexpbnv45a&#43;g6zkl546v">
                                    <h2 class="major">ArchLinux密钥环</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <p>由于升级到了 gnupg-2.1，pacman 上游更新了密钥环的格式，这使得本地的主密钥无法签署其它密钥。这不会出问题，除非你想自定义 pacman 密钥环。不过，我们推荐所有用户都生成一个新的密钥环以解决潜在问题。</p>
<p>此外，我们建议您安装 haveged，这是一个用来生成系统熵值的守护进程，它能加快加密软件（如 gnupg，包括生成新的密钥环）关键操作的速度。</p>
<p>要完成这些操作，请以 root 权限运行：</p>
<p>pacman -Syu haveged
systemctl start haveged
systemctl enable haveged</p>
<p>rm -fr /etc/pacman.d/gnupg
pacman-key &ndash;init
pacman-key &ndash;populate archlinux
pacman-key &ndash;populate archlinuxcn</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="helloworld">
                                    <h2 class="major">HelloWorld</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="welcome">Welcome</h1>
<p><strong>Hello world</strong>, this is my first Jekyll blog post.</p>
<p>I hope you like it!</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="sw50zxj2awv3ojpdkyvomzrlh73mlbat5p6e6ycg5ye95pww">
                                    <h2 class="major">Interview::C&#43;&#43;虚函数-构造函数</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="subject--c-构造函数可以是虚函数吗-析构函数可以是虚函数吗">Subject  C++ 构造函数可以是虚函数吗？ 析构函数可以是虚函数吗？</h1>
<ul>
<li>
<p>1.构造函数不能为虚函数</p>
<ul>
<li>
<p>当我们将构造函数定义为虚函数时,会直接报错:</p>
</li>
<li>
<p>首先回忆下以前学的virtual虚函数概念:</p>
</li>
<li>
<p>如果类定义了虚函数,创建对象时,则会分配内存空间,并且为该父类以及其所有子类的内存空间上额外分配一个虚函数表.</p>
</li>
<li>
<p>虚函数表的作用在于,存储每个类的相同的虚函数名,然后每一次虚函数调用,都会去虚函数表查找地址</p>
</li>
<li>
<p>分析:</p>
</li>
<li>
<p>假如构造函数是虚函数的话,由于对象开始还未分配内存空间,所以根本就无法找到虚函数表,从而构造函数也无法被调用.所以构造函数是不能成为虚函数.</p>
</li>
<li>
<p>2.析构函数可以为虚函数</p>
</li>
<li>
<p>首先回忆下析构函数:</p>
</li>
<li>
<p>当某个内对象被注销时,编译器会自动顺序调用该类以及其父类的析构函数,而不会调用派生类的析构函数.</p>
</li>
<li>
<p>虚析构函数的好处</p>
</li>
<li>
<p>假如我们通过派生类生成基类对象时,如果析构函数是虚函数,则我们释放其基类对象时,能使整个类(包括派生类)对象完全释放,如果析构函数只是普通函数,则不能析构完全.</p>
</li>
<li>
<p>分析:</p>
</li>
<li>
<p>所以当我们在用多态的时候(通过基类来调用派生类成员函数),析构函数最好为虚函数</p>
</li>
</ul>
<p>#include <!-- raw HTML omitted -->
using namespace std;</p>
<p>class ClassBase
{
public:
ClassBase(){};
virtual ~ClassBase()
{
cout&laquo;&quot;~ClassBase()&quot;&laquo;endl;
}</p>
<pre><code>virtual void func()                         //虚函数成员
{
    cout&lt;&lt;&quot;ClassBase: func()&quot;&lt;&lt;endl;
}
</code></pre>
<p>};</p>
<p>class ClassDerived : public ClassBase
{
public:
ClassDerived(){};
~ClassDerived()
{
cout&laquo;&quot;~ClassDerived()&quot;&laquo;endl;
}
void func()                    //虚函数成员
{
cout&laquo;&ldquo;ClassDerived: func()&quot;&laquo;endl;
}
};</p>
<p>int main()
{
ClassBase *p = new  ClassDerived;</p>
<pre><code> p-&gt;func();                   //通过多态来调用派生类虚函数

 delete p;

 return 0;
</code></pre>
<p>}</p>
<ul>
<li>
<p>打印如下:</p>
</li>
<li>
<p>ClassBase: func()</p>
</li>
<li>
<p>~ClassDerived()</p>
</li>
<li>
<p>~ClassBase()</p>
</li>
</ul>
</li>
</ul>

                                </article>
                            
                        
                    
                        
                            
                                <article id="interviewfive-ball-select-two">
                                    <h2 class="major">Interview::five-ball-select-two</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="subject">Subject</h1>
<ul>
<li>
<p>从2个红球，2个黄球，1个白球中随机取出两个球，则两球颜色不同的概率是___．.</p>
<ul>
<li>从5个球中任意取两个共有C52=10种，两球颜色相同的有2种，两球颜色不同的概率是1-2/10=4/5，
故答案为：4/5．
根据互斥时间的概率公式计算即可．
本题考点：古典概型及其概率计算公式</li>
</ul>
<p>考点点评： 本题考查了概率的基本性质和等可能事件的概率，求解方法采用了正难则反的原则，解答的关键是求出基本事件总数和发生事件的个数，属基本题型</p>
</li>
</ul>

                                </article>
                            
                        
                    
                        
                            
                                <article id="interviewfor-for-for">
                                    <h2 class="major">Interview::for-for-for</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="subject">Subject</h1>
<pre><code>        int a = 3;
        int b = 4;
        int c = 5;
        int x = 0;

        for (int i = 0; i &lt; a; i++)
        {
            for (int j = 0; j &lt; b; j++)
            {
                for (int k = 0; k &lt; c; k++)
                {
                    x++;
                }
            }
        }


任意断点 x 位置,根据 x 值 推断  i j  k,求出公式。


x = 58    k = 58%5=3  , j = 58/5=11%4=3, i =11/4=2
x = 33    k = 33%5=3  , j = 33/5=6%4=2, i =6/4=1
公式：
	k=x%c,j=x/c%b, i=x/c/b
</code></pre>

                                </article>
                            
                        
                    
                        
                            
                                <article id="interviewunity">
                                    <h2 class="major">Interview::unity</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="subject--assetbundleunload-true-和false-区别">Subject  assetBundle.Unload true 和false 区别</h1>
<pre><code>- 当传入的参数为true，则不仅仅内存中的AssetBundle对象包含的资源会被销毁。根据这些资源实例化而来的游戏内的对象也会销毁。

- 当传入的参数为false，则仅仅销毁内存中的AssetBundle对象包含的资源。
</code></pre>
<h1 id="unity-gc-机制">Unity GC 机制</h1>
<h1 id="战场优化">战场优化</h1>
<h2 id="模型预加载-动态图集-光效粒子-屏幕内外-自定义uimesh-gpu-instancing-容器扩容优化遍历容器线程安全容器">模型预加载 动态图集 光效粒子 屏幕内外 自定义UIMesh GPU Instancing, 容器扩容优化，遍历容器，线程安全容器</h2>
<h1 id="寻路--a--b">寻路  A*  B*</h1>
<h1 id="物理碰撞静态碰撞动态碰撞rvo">物理碰撞,静态碰撞。动态碰撞RVO</h1>
<h1 id="动态图集的优化原理是什么">动态图集的优化原理是什么</h1>
<h1 id="所谓动态图集就是没有办法静态生成的需要在运行时动态生成的图集那么我们为什么需要动态图集">所谓动态图集就是没有办法静态生成的，需要在运行时动态生成的图集，那么我们为什么需要动态图集？</h1>
<h2 id="动态图集是为了解决游戏中动态图片太多的问题也就是我们没有办法预先放在ui上的下图案例中可以看到右下角的英雄技能图标天赋技能图标以及主动使用的物品图片均为动态加载左上角的英雄头像也是动态加载而且由于技能之类的图片太多毕竟有几十个英雄所以没有办法打成一张静态图集而如果作为独立图片动态加载就会多十几个drawcall即便是打成多张静态图集也会导致ui渲染的批次被打断">动态图集是为了解决游戏中动态图片太多的问题，也就是我们没有办法预先放在UI上的。下图案例中可以看到右下角的英雄技能图标、天赋技能图标，以及主动使用的物品图片，均为动态加载。左上角的英雄头像也是动态加载，而且由于技能之类的图片太多（毕竟有几十个英雄），所以没有办法打成一张静态图集。而如果作为独立图片动态加载，就会多十几个DrawCall。即便是打成多张静态图集，也会导致UI渲染的批次被打断。</h2>
<h2 id="解决方案用动态打图集的方式因为我们没有unity源码所以图集的分块算法参考了这个开源项目-httpdavikingcodecomblogunity-generate-spritesheets-at-runtime这个算法效率比较不错建议大家可以研究一下它的分块算法的思路上本质上类似于bsp">解决方案：用动态打图集的方式。因为我们没有Unity源码，所以图集的分块算法参考了这个开源项目 <a href="http://davikingcode.com/blog/unity-generate-spritesheets-at-runtime/">http://davikingcode.com/blog/unity-generate-spritesheets-at-runtime/</a>，这个算法效率比较不错，建议大家可以研究一下，它的分块算法的思路上本质上类似于BSP。</h2>
<h2 id="大图集是在游戏loading时获得动态图片然后把这些动态图片渲染到rendertexture上用gpu的方式来做可以保证加载的效率在游戏中英雄头像使用了一张256x256的rendertexture而英雄技能天赋技能和物品图标使用了一张512x512的rendertexture这样一来技能面板动态图标的消耗从12个drawcall降低到1个drawcall而英雄头像部分从最多9个drawcall降低到2个drawcall这个结果是因为敌我双方英雄头像使用的材质不同实际操作中技能面板的动态图片放在同一个层级里这样就只有1个drawcall上面的蒙板边框零散图片打成静态图集在不出现穿插的情况下ugui也会协助合批因此通过这种方式大量减少了drawcall后面讲到的一些点其实也用到了动态图集">大图集是在游戏Loading时获得动态图片，然后把这些动态图片渲染到RenderTexture上，用GPU的方式来做可以保证加载的效率。在游戏中，英雄头像使用了一张256x256的RenderTexture，而英雄技能、天赋技能和物品图标使用了一张512x512的RenderTexture。这样一来，技能面板动态图标的消耗从12个DrawCall降低到1个DrawCall。而英雄头像部分，从最多9个DrawCall降低到2个DrawCall，这个结果是因为敌我双方英雄头像使用的材质不同。实际操作中，技能面板的动态图片放在同一个层级里，这样就只有1个DrawCall，上面的蒙板、边框零散图片打成静态图集，在不出现穿插的情况下，UGUI也会协助合批。因此通过这种方式大量减少了DrawCall。后面讲到的一些点其实也用到了动态图集。</h2>
<h1 id="渲染流水线的原理">渲染流水线的原理</h1>
<h2 id="渲染流程可以分为三个阶段应用阶段几何阶段光栅化阶段">渲染流程，可以分为三个阶段。应用阶段，几何阶段，光栅化阶段</h2>
<h1 id="ecs-优缺点和mvc这些相比-为啥选ecs">ecs 优缺点，和mvc这些相比。 为啥选ecs</h1>
<h2 id="mvc-面向对象继承多态封装高度耦合-一个英雄charactor包含了-属性状态控制器">mvc 面向对象,（继承，多态，封装）高度耦合， 一个英雄charactor包含了 属性，状态，控制器</h2>
<h2 id="ecs-面向数据组合模式推崇组合优于继承理念函数式编程system只对他关系的component负责业务上更加专一遍历内存上更加高效保证内存的连续性业务拆分的越细-代码复用率越高">ecs 面向数据：（组合模式）推崇组合优于继承理念，函数式编程，system只对他关系的component负责。业务上更加专一。遍历内存上更加高效（保证内存的连续性）,业务拆分的越细 代码复用率越高</h2>
<h1 id="帧同步">帧同步</h1>
<h2 id="浮点类型多线程随机种子静态变量全局变量容器顺序需要确定性">浮点类型，多线程，随机种子，静态变量，全局变量，容器顺序需要确定性</h2>
<h1 id="内存和虚拟内存的区别">内存和虚拟内存的区别</h1>
<h2 id="指的是把硬盘中的一部分空间用来当做内存使用虚拟内存的作用是为了解决计算机在运行较大的程序时内存不足的情况虚拟内存是在硬盘上的它的速度要比内存慢的多虚拟内存其实就是为了运行很大的程序的一种妥协的办法妥协了软件的运行速度">指的是把硬盘中的一部分空间用来当做内存使用,虚拟内存的作用：是为了解决计算机在运行较大的程序时内存不足的情况,虚拟内存是在硬盘上的，它的速度要比内存慢的多，虚拟内存其实就是为了运行很大的程序的一种妥协的办法，妥协了软件的运行速度。</h2>
<h1 id="子类为什么可以赋值给基类对象">子类为什么可以赋值给基类对象</h1>
<h2 id="基类的指针可以指向派生类对象但是反过来则不行派生类的指针不可以指向基类的指针这是为什么呢这是因为派生类的对象所占的存储空间通常要比基类的对象大原因就是派生类除了继承基类的成员之外还拥有自己的成员所以基类的指针操作派生类的对象时由于基类指针会向操作基类对象那样操作派生类对象而基类对象所占用的内存空间通常小于派生类对象所以基类指针不会超出派生类对象去操作数据">基类的指针可以指向派生类对象，但是反过来则不行，派生类的指针不可以指向基类的指针。这是为什么呢？这是因为派生类的对象所占的存储空间通常要比基类的对象大，原因就是派生类除了继承基类的成员之外，还拥有自己的成员，所以基类的指针操作派生类的对象时，由于基类指针会向操作基类对象那样操作派生类对象，而基类对象所占用的内存空间通常小于派生类对象，所以基类指针不会超出派生类对象去操作数据。</h2>
<h2 id="同样的道理基类的引用可以作为派生类对象的别名但是反过来则不行派生类的引用不可以作为基类对象的别名">同样的道理，基类的引用可以作为派生类对象的别名，但是反过来则不行，派生类的引用不可以作为基类对象的别名。</h2>
<h1 id="自定义的ui-mesh">自定义的UI Mesh</h1>
<h2 id="构造出来的mesh使用一个单独的正交摄像机来绘制">构造出来的Mesh使用一个单独的正交摄像机来绘制，</h2>
<h2 id="在ui-mesh的构造函数中可以看到是创建了一个gameobject附加meshfilter和meshrenderer然后再做一些初始化的工作">在UI Mesh的构造函数中可以看到是创建了一个GameObject，附加MeshFilter和MeshRenderer，然后再做一些初始化的工作。</h2>
<h2 id="重点在于自行填充mesh的三个buffer位置uv和索引另外为了避免在运行时重复申请内存在初始化的时候要申请足够多的顶点">重点在于自行填充Mesh的三个Buffer：位置、UV和索引。另外为了避免在运行时重复申请内存，在初始化的时候要申请足够多的顶点。</h2>
<h2 id="在实际游戏中用到了多个ui-mesh总体的顶点数大概在3000左右">在实际游戏中用到了多个UI Mesh，总体的顶点数大概在3000左右。</h2>
<h2 id="初始化mesh之后还要去维护顶点buffer一个小兵的血条包含背景底框和前景血条2个矩形8个顶点在游戏中去动态地改变这8个顶点的位置如果某个actor不在视野中那么把它所有顶点坍缩到一个点就不显示了另外actor死亡的时候并不删除它的数据而是先设置为不显示然后缓存起来准备复用也就是说无论整场战斗创建了多少个角色实际上血条都是在这个mesh的buffer里不断复用">初始化Mesh之后，还要去维护顶点Buffer。一个小兵的血条包含背景底框和前景血条，2个矩形8个顶点，在游戏中去动态地改变这8个顶点的位置。如果某个Actor不在视野中，那么把它所有顶点坍缩到一个点就不显示了。另外，Actor死亡的时候，并不删除它的数据，而是先设置为不显示，然后缓存起来准备复用。也就是说无论整场战斗创建了多少个角色，实际上血条都是在这个Mesh的Buffer里不断复用。</h2>
<h1 id="heading">================================================================================================================================</h1>
<h1 id="net装箱拆箱的概念">(.net)装箱拆箱的概念</h1>
<h2 id="heading-1"></h2>
<h2 id="装箱是将值类型转换为-object-类型或由此值类型实现的任何接口类型的过程-clr-对值类型进行装箱时会将值包装在-systemobject-实例中并将其存储在托管堆中">装箱是将值类型转换为 object 类型或由此值类型实现的任何接口类型的过程. CLR 对值类型进行装箱时，会将值包装在 System.Object 实例中并将其存储在托管堆中。</h2>
<h2 id="拆箱取消装箱将从对象中提取值类型-装箱是隐式的取消装箱是显式的">拆箱(取消装箱)将从对象中提取值类型。 装箱是隐式的；取消装箱是显式的。</h2>
<h2 id="int-i-1">int i =1;</h2>
<h2 id="object-o--i-装箱">object o = i; //装箱</h2>
<h2 id="i--into--拆箱">i = (int)o;  //拆箱</h2>
<h1 id="3d数学4元数的做用是什么-相比欧拉角的优点有哪些">(3D数学)4元数的做用是什么? 相比欧拉角的优点有哪些?</h1>
<h2 id="图形学用4元数表示旋转">图形学用4元数表示旋转.</h2>
<h2 id="1-解决万向节死锁问题-2-四元数方便插值-求逆运算">1) 解决万向节死锁问题; 2) 四元数方便插值, 求逆运算</h2>
<h1 id="图形学深度缓冲区depth-buffer是什么-有什么作用-模板缓冲stencil-buffer是什么-有什么作用">(图形学)深度缓冲区(Depth Buffer)是什么? 有什么作用? 模板缓冲(stencil buffer)是什么, 有什么作用?</h1>
<h2 id="深度缓冲区或-z-缓冲区存储深度信息以控制渲染哪些多边形区域用于决定不透明物体是否被绘制">深度缓冲区（或 z 缓冲区）存储深度信息，以控制渲染哪些多边形区域。用于决定不透明物体是否被绘制.</h2>
<h2 id="模具缓冲区用于遮罩图像中的像素以产生特殊效果-掩码控制是否绘制像素-特殊效果包括合成贴纸溶解淡化滑动轮廓描绘和剪影-模板缓冲区逐个像素地启用或禁用渲染目标图面绘制-究其本质它使应用程序遮罩部分渲染图像因此这些部分不会显示-应用程序常常使用模板缓冲区实现特殊效果例如溶解贴纸和轮廓描绘">模具缓冲区用于遮罩图像中的像素，以产生特殊效果。 掩码控制是否绘制像素。 特殊效果包括合成、贴纸、溶解、淡化、滑动、轮廓描绘和剪影, 模板缓冲区逐个像素地启用或禁用渲染目标图面绘制。 究其本质，它使应用程序遮罩部分渲染图像，因此这些部分不会显示。 应用程序常常使用模板缓冲区实现特殊效果，例如溶解、贴纸和轮廓描绘。</h2>
<h1 id="图形学纹理是什么-unity常用的纹理类型有哪些--常用的纹理压缩格式有哪些列举3种">(图形学)纹理是什么? Unity常用的纹理类型有哪些?  常用的纹理压缩格式有哪些?(列举3种)</h1>
<h2 id="纹理是为图形对象mesh提供纹理外观的像素颜色的位图-位图资源jpeg-png-加载到引擎后变为纹理资源-纹理资源是存储纹素的数据结构--纹素是可以读取或者写入纹理的最小单位-在着色器读取纹理时-可以通过采样器对纹理进行筛选和读取-纹理有1d纹理-2d纹理和3d纹理-纹理经常包括若干层级的mipmap">纹理是为图形对象(mesh)提供纹理外观的像素颜色的位图. 位图资源(jpeg, png) 加载到引擎后变为纹理资源, 纹理资源是存储纹素的数据结构,  纹素是可以读取或者写入纹理的最小单位. 在着色器读取纹理时, 可以通过采样器对纹理进行筛选和读取. 纹理有1d纹理, 2d纹理和3d纹理. 纹理经常包括若干层级的mipmap.</h2>
<h2 id="类型有-default-sprite2d-andui-normalmap-editorgui-ligthmap-cookie">类型有 Default, Sprite(2D andUI), NormalMap, EditorGUI, Ligthmap, Cookie</h2>
<h2 id="windows下有-dxt5">windows下有 DXT5</h2>
<h2 id="android系统下常用-etc1-etc2">Android系统下常用 ETC1, ETC2,</h2>
<h2 id="ios-常用-pvrtc">iOS 常用 PVRTC</h2>
<h1 id="图形学-uv坐标是什么">(图形学) UV坐标是什么?</h1>
<h2 id="todo-待完善">//todo: 待完善.</h2>
<h2 id="uv坐标是归一化后normalized的纹素坐标">uv坐标是归一化后(Normalized)的纹素坐标.</h2>
<h2 id="heading-2">??</h2>
<h1 id="图形学mipmap是什么作用">(图形学)MipMap是什么，作用？</h1>
<h2 id="mipmapping在三维计算机图形的贴图渲染中有常用的技术为加快渲染进度和减少图像锯齿贴图被处理成由一系列被预先计算和优化过的图片组成的文件这样的贴图被称为mipmap">MipMapping：在三维计算机图形的贴图渲染中有常用的技术，为加快渲染进度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为MipMap。</h2>
<h1 id="c-难度-较高泛型接口的抗变也叫逆变-contravariance和协变covariance有什么区别">(C# 难度: 较高)泛型接口的抗变(也叫逆变 Contravariance)和协变(Covariance)有什么区别?</h1>
<h2 id="先说定义-协变和逆变能够实现数组类型委托类型和泛型类型参数的隐式引用转换">先说定义, 协变和逆变能够实现数组类型、委托类型和泛型类型参数的隐式引用转换。</h2>
<h1 id="在面向对象设计中子类的实例可以赋值给父类类型的变量-这是协变-如-object-o--hello-是正确的-这个是符合里氏替换原则-但是-string-s--new-object-这样的隐式转换语法不允许的-除非自定义了等号操作符-但是逆变让这种隐私转换变为合法的当然有很多前置条件">在面向对象设计中子类的实例可以赋值给父类类型的变量, 这是协变. 如 object o = &ldquo;hello&rdquo; 是正确的, 这个是符合里氏替换原则, 但是 string s = new object(), 这样的隐式转换语法不允许的, 除非自定义了等号操作符. 但是逆变让这种隐私转换变为合法的,当然有很多前置条件,</h1>
<h2 id="首先必须是数组类型泛型委托或者泛型接口">首先必须是数组类型,泛型委托或者泛型接口.</h2>
<h2 id="泛型参数必须用-in-关键字修饰--也就是说这个泛型参数只能作为方法的形参类型-而不能是返回值">泛型参数必须用 in 关键字修饰.  也就是说这个泛型参数只能作为方法的形参类型, 而不能是返回值.</h2>
<h2 id="net-framework4-之后支持变体泛型接口">.net framework4 之后支持变体泛型接口.</h2>
<h2 id="委托的逆变的好处可以使用一个事件处理程序-而不是多个单独的处理程序-下面代码演示了委托的逆变">委托的逆变的好处可以使用一个事件处理程序, 而不是多个单独的处理程序, 下面代码演示了委托的逆变.</h2>
<h2 id="heading-3">??</h2>
<h2 id="泛型接口的逆变的设计还有待发掘-欢迎补充演示代码">泛型接口的逆变的设计还有待发掘, 欢迎补充演示代码.</h2>
<h2 id="下面的代码演示了分配兼容性-协变和逆变的差异">下面的代码演示了分配兼容性, 协变和逆变的差异</h2>
<h2 id="-分配兼容性">// 分配兼容性</h2>
<h2 id="string-str--test">string str = &ldquo;test&rdquo;;</h2>
<h2 id="-子类实例可以赋值给父类">// 子类实例可以赋值给父类</h2>
<h2 id="object-obj--str">object obj = str;</h2>
<h2 id="-协变接口-用out关键字参数定义">// 协变接口, 用out关键字参数定义</h2>
<h2 id="public-interface-ienumerableout-t--systemcollectionsienumerable">public interface IEnumerable<!-- raw HTML omitted --> : System.Collections.IEnumerable</h2>
<h2 id="ienumerablestring-strings--new-liststring">IEnumerable<!-- raw HTML omitted --> strings = new List<!-- raw HTML omitted -->();</h2>
<h2 id="-ienumableobject-的泛型参数类型是-object-ienumrablestring-泛型参数类型是string--下面这样的赋值-协变符合分配兼容性">// IEnumable<!-- raw HTML omitted --> 的泛型参数类型是 object, IEnumrable<!-- raw HTML omitted --> 泛型参数类型是string,  下面这样的赋值 协变符合分配兼容性</h2>
<h2 id="ienumerableobject-objects--strings">IEnumerable<!-- raw HTML omitted --> objects = strings;</h2>
<h1 id="-逆变委托">// 逆变委托</h1>
<h2 id="-假设有一个这样的类函数">// 假设有一个这样的类函数</h2>
<h2 id="static-void-setobjectobject-o--">static void SetObject(object o) { }</h2>
<h2 id="public-delegate-void-actionin-t--逆变的t-支持父类实例赋值给子类类型">public delegate void Action<!-- raw HTML omitted -->  //逆变的T, 支持父类实例赋值给子类类型</h2>
<h2 id="actionobject-actobject--setobject--给具有逆变的委托赋值一个方法实例">Action<!-- raw HTML omitted --> actObject = SetObject;  给具有逆变的委托赋值一个方法实例</h2>
<h2 id="-下面的操作是逆变-父类参数object实例赋值给子类类型string">// 下面的操作是逆变, 父类参数object实例赋值给子类类型string</h2>
<h2 id="-逆变违反了分配兼容">// 逆变违反了分配兼容</h2>
<h2 id="actionstring-actstring--actobject">Action<!-- raw HTML omitted --> actString = actObject;</h2>
<h2 id="当泛型参数用-out-关键字修饰-意味着其为协变泛型接口-这时接口的方法只能把-t-作为函数的返回值类型-而不能作为函数的形参类型-如">当泛型参数用 out 关键字修饰, 意味着其为协变泛型接口, 这时接口的方法只能把 T 作为函数的返回值类型, 而不能作为函数的形参类型 如:</h2>
<h2 id="协变接口">//协变接口</h2>
<h2 id="public-interface-ienumerableout-t--systemcollectionsienumerable-1">public interface IEnumerable<!-- raw HTML omitted --> : System.Collections.IEnumerable</h2>
<h2 id="heading-4">{</h2>
<h2 id="t-myfunciton---正确-t是协变">T MyFunciton();  // 正确, T是协变</h2>
<h2 id="-编译错误-error-cs1961-变型无效-类型参数t必须是在">// 编译错误 error CS1961: 变型无效: 类型参数“T”必须是在</h2>
<h2 id="-interface1tfunction2t上有效的-逆变式t为-协变">// “interface1<!-- raw HTML omitted -->.function2(T)”上有效的 逆变式。“T”为 协变。</h2>
<h2 id="void-myfunciton2t-t">void MyFunciton2(T t);</h2>
<h2 id="heading-5">}</h2>
<h2 id="当泛型参数用-in-关键字修饰-意味着逆变--t只能作为方法的形参类型-不能作为函数的返回值类型">当泛型参数用 in 关键字修饰, 意味着逆变 , T只能作为方法的形参类型, 不能作为函数的返回值类型</h2>
<h2 id="public-interface-iequalitycomparerin-t">public interface IEqualityComparer<!-- raw HTML omitted --></h2>
<h2 id="heading-6">{</h2>
<h2 id="void-myfunctiont-t-正确">void MyFunction(T t); //正确,</h2>
<h2 id="t-myfunction2--编译错误--error-cs1961-变型无效-类型参数t必须是在interface2tfunction2上有效的-协变式t为-逆变">T MyFunction2();  //编译错误  error CS1961: 变型无效: 类型参数“T”必须是在“interface2<!-- raw HTML omitted -->.function2()”上有效的 协变式。“T”为 逆变。</h2>
<h2 id="heading-7">}</h2>
<h1 id="泛型接口的抗变和协变统称为变体泛型接口-以上资料参考">泛型接口的抗变和协变统称为变体泛型接口 以上资料参考:</h1>
<h2 id="c中的逆变和协变httpsdocsmicrosoftcomzh-cndotnetcsharpprogramming-guideconceptscovariance-contravariance"><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/">c#中的逆变和协变</a></h2>
<h2 id="委托中变体httpsdocsmicrosoftcomzh-cndotnetcsharpprogramming-guideconceptscovariance-contravarianceusing-variance-in-delegates"><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-delegates">委托中变体</a></h2>
<h2 id="泛型接口中的变体httpsdocsmicrosoftcomzh-cndotnetcsharpprogramming-guideconceptscovariance-contravariancevariance-in-generic-interfaces"><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/variance-in-generic-interfaces">泛型接口中的变体</a></h2>
<h2 id="在泛型集合的接口中使用变体httpsdocsmicrosoftcomzh-cndotnetcsharpprogramming-guideconceptscovariance-contravarianceusing-variance-in-interfaces-for-generic-collections"><a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/programming-guide/concepts/covariance-contravariance/using-variance-in-interfaces-for-generic-collections">在泛型集合的接口中使用变体</a></h2>
<h1 id="动态加载资源的方式">动态加载资源的方式？</h1>
<h2 id="1resourcesload">1.Resources.Load();</h2>
<h2 id="2assetbundle">2.AssetBundle</h2>
<h2 id="heading-8">??</h2>
<h2 id="assetbundle相关">AssetBundle相关</h2>
<h2 id="在通过assetbundleunloadfalse卸载assetbundle对象后如果重新创建该对象并加载之前加载过的资源到内存时会出现冗余即两份相同的资源">在通过AssetBundle.Unload(false)卸载AssetBundle对象后，如果重新创建该对象并加载之前加载过的资源到内存时，会出现冗余，即两份相同的资源。</h2>
<h2 id="被脚本的静态变量引用的资源在调用resourcesunloadunusedassets时并不会被卸载在profiler中能够看到其引用情况">被脚本的静态变量引用的资源，在调用Resources.UnloadUnusedAssets时，并不会被卸载，在Profiler中能够看到其引用情况。</h2>
<h1 id="unity3d从唤醒到销毁有一段生命周期请列出系统自己调用的几个重要方法">unity3d从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法？</h1>
<h2 id="答awake------start-----update-----fixedupdate----lateupdate----ongui---reset----ondisable---ondestory">答：Awake &mdash;&gt;  Start &mdash;&gt; Update  &ndash;&gt; FixedUpdate &ndash;&gt; LateUpdate &mdash;&gt;OnGUI &ndash;&gt;Reset &ndash;&gt; OnDisable &ndash;&gt;OnDestory;</h2>
<h1 id="什么是协同程序">什么是协同程序？</h1>
<h2 id="在主线程运行的同时开启另一段逻辑处理来协助当前程序的执行协程很像多线程但是不是多线程unity的协程是在每帧结束之后去检测yield的条件是否满足">在主线程运行的同时开启另一段逻辑处理，来协助当前程序的执行，协程很像多线程，但是不是多线程，Unity的协程是在每帧结束之后去检测yield的条件是否满足。</h2>
<h1 id="lod是什么优缺点是什么">LOD是什么，优缺点是什么？</h1>
<h2 id="lodlevel-of-detail多层次细节是最常用的游戏优化技术它按照模型的位置和重要程度决定物体渲染的资源分配降低非重要物体的面数和细节度从而获得高效率的渲染运算缺点是增加了内存">LOD(Level of detail)多层次细节，是最常用的游戏优化技术。它按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。缺点是增加了内存。</h2>
<h1 id="什么叫动态合批跟静态合批有什么区别">什么叫动态合批？跟静态合批有什么区别？</h1>
<h2 id="如果动态物体共用着相同的材质那么unity会自动对这些物体进行批处理动态批处理操作是自动完成的并不需要你进行额外的操作">如果动态物体共用着相同的材质，那么Unity会自动对这些物体进行批处理。动态批处理操作是自动完成的，并不需要你进行额外的操作。</h2>
<h2 id="区别动态批处理一切都是自动的不需要做任何操作而且物体是可以移动的但是限制很多">区别：动态批处理一切都是自动的，不需要做任何操作，而且物体是可以移动的，但是限制很多。</h2>
<h2 id="静态批处理自由度很高限制很少缺点可能会占用更多的内存而且经过静态批处理后的所有物体都不可以再移动了">静态批处理：自由度很高，限制很少，缺点可能会占用更多的内存，而且经过静态批处理后的所有物体都不可以再移动了</h2>
<h1 id="6大oo设计原则">6大OO设计原则？</h1>
<h2 id="1开闭原则">1.开闭原则</h2>
<h2 id="2单一职责原则">2.单一职责原则</h2>
<h2 id="3依赖倒置原则">3.依赖倒置原则</h2>
<h2 id="4接口隔离原则">4.接口隔离原则</h2>
<h2 id="5迪米特法则">5.迪米特法则</h2>
<h2 id="6里氏替换原则">6.里氏替换原则</h2>
<h1 id="什么是里氏代换原则">什么是里氏代换原则？</h1>
<h2 id="里氏替换原则liskov-substitution-principle-lsp面向对象设计的基本原则之一通俗点就是子类对象可以赋值给基类对象基类对象不能赋值给子类对象">里氏替换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。通俗点：就是子类对象可以赋值给基类对象，基类对象不能赋值给子类对象</h2>
<h2 id="你能说出几种创建型模式">你能说出几种创建型模式</h2>
<h2 id="抽象工厂">抽象工厂</h2>
<h2 id="建造者">建造者</h2>
<h2 id="工厂">工厂</h2>
<h2 id="原型模式克隆模式">原型模式/克隆模式</h2>
<h2 id="单例模式">单例模式</h2>
<h2 id="简述mvcmvpmvvm三种模式">简述MVC、MVP、MVVM三种模式</h2>
<h2 id="你有了解过多少种软件的分层结构">你有了解过多少种软件的分层结构</h2>
<h2 id="三层架构六边形洋葱架构整洁架构">三层架构、六边形、洋葱架构、整洁架构</h2>
<h1 id="在编辑场景时将gameobject设置为static有何作用">在编辑场景时将GameObject设置为Static有何作用？</h1>
<h2 id="设置游戏对象为static时这些部分被静态物体挡住而不可见时将会剔除或禁用网格对象因此在你的场景中的所有不会动的物体都应该标记为static">设置游戏对象为Static时，这些部分被静态物体挡住而不可见时，将会剔除（或禁用）网格对象。因此，在你的场景中的所有不会动的物体都应该标记为Static。</h2>
<h2 id="如果你在游戏中编写一个类不想让其他同事继承这个类你会怎么办">如果你在游戏中编写一个类，不想让其他同事继承这个类，你会怎么办？</h2>
<h2 id="在类声明时与函数声明时的作用sealed修饰的类为密封类类声明时可防止其他类继承此类在方法中声明则可防止派生类重写此方法">在类声明时与函数声明时的作用sealed修饰的类为密封类，类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。</h2>
<h1 id="如何理解委托">如何理解委托？</h1>
<h2 id="委托类似于-c-函数指针但它是类型安全的委托允许将方法作为参数进行传递委托可用于定义回调方法委托可以链接在一起例如可以对一个事件调用多个方法方法不需要与委托签名精确匹配">委托类似于 C++ 函数指针，但它是类型安全的。委托允许将方法作为参数进行传递。委托可用于定义回调方法。委托可以链接在一起；例如，可以对一个事件调用多个方法。方法不需要与委托签名精确匹配。</h2>
<h2 id="gc是什么-为什么要有gc">GC是什么? 为什么要有GC？</h2>
<h2 id="gc是垃圾收集器程序员不用担心内存管理因为垃圾收集器会自动进行管理要请求垃圾收集可以调用下面的方法之一-systemgc-runtimegetruntimegc">GC是垃圾收集器。程序员不用担心内存管理，因为垃圾收集器会自动进行管理。要请求垃圾收集，可以调用下面的方法之一： System.gc() Runtime.getRuntime().gc()</h2>
<h1 id="死锁的必要条件怎么克服">死锁的必要条件？怎么克服？</h1>
<h2 id="系统的资源不足进程的推进的顺序不合适资源分配不当一个资源每次只能被一个进程使用一个资源请求资源时而此时这个资源已阻塞对已获得资源不放进程获得资源时未使用完前不能强行剥夺">系统的资源不足，进程的推进的顺序不合适，资源分配不当，一个资源每次只能被一个进程使用，一个资源请求资源时，而此时这个资源已阻塞，对已获得资源不放，进程获得资源时，未使用完前，不能强行剥夺。</h2>
<h1 id="c是否可以对内存直接进行操作">C#是否可以对内存直接进行操作？</h1>
<h2 id="c是可以对内存进行直接操作的虽然很少用到指针但是c是可以使用指针的在用的时候需要在前边加unsafe在net中使用了垃圾回收机制gc功能它替代了程序员不过在c中不可以直接使用finalize方法而是在析构函数中调用基类的finalize方法">C#是可以对内存进行直接操作的，虽然很少用到指针，但是C#是可以使用指针的，在用的时候需要在前边加unsafe,，在.net中使用了垃圾回收机制（GC）功能，它替代了程序员，不过在C#中不可以直接使用finalize方法，而是在析构函数中调用基类的finalize()方法。</h2>
<h1 id="tcpudp协议在osi七层模型和si七层模型和tcpip四层模型中分别属于哪一层的网络协议">TCP、UDP协议在OSI七层模型和SI七层模型和TCP/IP四层模型中分别属于哪一层的网络协议？</h1>
<h2 id="都是属于传输层的网络协议传输层提供了应用程序之间的通信">都是属于传输层的网络协议。传输层提供了应用程序之间的通信。</h2>
<h2 id="如何实现可靠udp">如何实现可靠UDP？</h2>
<h1 id="高级ugui性能优化">（高级）UGUI性能优化</h1>
<h2 id="1动静分离将程序会动态设置的组件跟静态组件分离">1.动静分离，将程序会动态设置的组件跟静态组件分离</h2>
<h2 id="2文本与图片穿插编排会打断drawcall">2.文本与图片穿插编排会打断DrawCall</h2>
<h2 id="3静态合并图集降低drawcall">3.静态合并图集，降低DrawCall</h2>
<h2 id="4对于复杂的场景可以考虑动态合并图集降低drawcall">4.对于复杂的场景，可以考虑动态合并图集，降低DrawCall</h2>
<h2 id="5使用多个canvasrender例如一个界面一个canvasrender">5.使用多个CanvasRender，例如一个界面一个CanvasRender</h2>
<h2 id="6降低mesh重建次数">6.降低Mesh重建次数</h2>
<h2 id="7隐藏物件可以使用scale0-移动到非渲染层级移动位置到相机外关闭canvasrender">7.隐藏物件可以使用Scale=0, 移动到非渲染层级，移动位置到相机外，关闭CanvasRender</h2>
<h1 id="高级游戏热更新">（高级）游戏热更新</h1>
<h2 id="代码热更新的具体方案--lua-ilrt">代码热更新的具体方案:  lua, ILRT</h2>
<h2 id="资源热更新的具体方案-ab">资源热更新的具体方案: AB</h2>
<h2 id="资源分发方案">资源分发方案</h2>
<h2 id="外部玩家存在不同的版本如何同步升级这些版本-打包差异升级包-版本号">外部玩家存在不同的版本，如何同步升级这些版本: 打包差异升级包, 版本号</h2>
<h1 id="高级游戏sdk">（高级）游戏SDK</h1>
<h2 id="渠道如何打包">渠道如何打包</h2>
<h2 id="渠道sdk如何接入">渠道SDK如何接入</h2>
<h1 id="数组和链表的区别">数组和链表的区别</h1>
<h2 id="从逻辑结构上来看数组必须实现定于固定的长度不能适应数据动态增减的情况即数组的大小一旦定义就不能改变当数据增加是可能超过原先定义的元素的个数当数据减少时造成内存浪费">从逻辑结构上来看，数组必须实现定于固定的长度，不能适应数据动态增减的情况，即数组的大小一旦定义就不能改变。当数据增加是，可能超过原先定义的元素的个数；当数据减少时，造成内存浪费；</h2>
<h2 id="链表动态进行存储分配可以适应数据动态地增减的情况且可以方便地插入删除数据项">链表动态进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据项。</h2>
<h2 id="从内存存储的角度看数组从栈中分配空间用new则在堆上创建对程序员方便快速但是自由度小链表从堆中分配空间自由度大但是申请管理比较麻烦">从内存存储的角度看；数组从栈中分配空间（用new则在堆上创建），对程序员方便快速，但是自由度小；链表从堆中分配空间，自由度大但是申请管理比较麻烦。</h2>
<h2 id="从访问方式类看数组在内存中是连续的存储因此可以利用下标索引进行访问链表是链式存储结构在访问元素时候只能够通过线性方式由前到后顺序的访问所以访问效率比数组要低">从访问方式类看，数组在内存中是连续的存储，因此可以利用下标索引进行访问；链表是链式存储结构，在访问元素时候只能够通过线性方式由前到后顺序的访问，所以访问效率比数组要低。</h2>
<h1 id="核心素质">核心素质：</h1>
<h2 id="抗压能力组织协调能力学习能力解决问题能力主动反馈执行力">抗压能力、组织协调能力、学习能力、解决问题能力、主动反馈、执行力</h2>
<h1 id="专业能力">专业能力：</h1>
<h2 id="完整的上线项目经历架构业务设计能力工程管理规范文档代码审核">完整的上线项目经历、架构/业务设计能力、工程管理（规范、文档、代码审核）</h2>

                                </article>
                            
                        
                    
                        
                            
                                <article id="rustchannels">
                                    <h2 class="major">Rust::Channels</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="flavors">Flavors:</h1>
<ul>
<li>Synchronous channels: Channel where send() can block. Limited capacity.
<ul>
<li>Mutex + Condvar + VecDeque</li>
<li>Atomic VecDeque (atomic queue) + thread::pack + thread::Thread::notify</li>
</ul>
</li>
<li>Asynchronous channels: Channel where send() cannot block. Unbounded.
<ul>
<li>Mutex + Condvar + VecDeque</li>
<li>Mutex + Condvar + LinkedList</li>
<li>AtomicLinkedList or Atomic Queue</li>
<li>Atomic linked list, linked list of T</li>
<li>Atomic block linked list, linked of atomic VecDeque<!-- raw HTML omitted --></li>
</ul>
</li>
<li>Rendezvous channels: Synchronous with capacity = 0. Used for thread synchronization.</li>
<li>Oneshot channels: Any capacity. In practice, only one call to send().</li>
</ul>

                                </article>
                            
                        
                    
                        
                            
                                <article id="rustmio">
                                    <h2 class="major">Rust::mio</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="flavors">Flavors:</h1>
<ul>
<li>from url: <a href="https://blog.csdn.net/s_lisheng/article/details/80593426">https://blog.csdn.net/s_lisheng/article/details/80593426</a></li>
</ul>
<p>【Rust】轻量级I/O库mio</p>
<p>让我思考一下 2018-06-06 12:53:45  4054  收藏 3
分类专栏： Rust 文章标签： Rust mio
版权
mio是rust实现的一个轻量级的I/O库。其实现基本上就是对不同操作系统底层相关API的封装，抽象出统一的接口供上层使用。Linux下为epoll，Windows下为IOCP，OS X下为kqueue。</p>
<p>一、关于mio
1、重要特性
非阻塞TCP，UDP
I/O事件通知epoll,kqeue,IOCP实现
运行时零分配
平台可扩展
2、基础用法
其使用方法与Linux中epoll差不多，mio底层封装了epoll，使用步骤思路：</p>
<p>创建Poll
注册事件
事件循环等待与处理事件
mio提供可跨平台的sytem selector访问，不同平台如下表，都可调用相同的API。不同平台使用的API开销不尽相同。由于mio是基于readiness(就绪状态)的API，与Linux epoll相似，可以看到很多API在Linux上都可以一对一映射。相比之下，Windows IOCP是基于完成（completion-based）而非基于就绪的API，所以两者间会有较多桥接。 同时mio提供自身版本的TcpListener、TcpStream、UdpSocket，这些API封装了底层平台相关API，并设为非阻塞且实现Evented trait。</p>
<p>OS	Selector
Linux	epoll
OS X, iOS	kqueue
Windows	IOCP
FreeBSD	kqueue
Android	epoll
mio实现的是一个单线程事件循环，并没有实现线程池及多线程事件循环，如果需要线程池及多线程事件循环等需要自己实现。</p>
<p>二、源码分析
先给出mio的源码目录结构，只列出了关键的部分，如下所示：</p>
<p>mio代码目录结构
mio
|&mdash;-&gt;test
|&mdash;-&gt;src
|&mdash;&mdash;&ndash;&gt;deprecated			//事件循环代码
|&mdash;&mdash;&mdash;&mdash;&ndash;&gt;event_loop.rs		//EventLoop的实现，内部封装了Poll		【1】
|&mdash;&mdash;&mdash;&mdash;&ndash;&gt;handler.rs			//供上层实现的接口
|&mdash;&mdash;&ndash;&gt;net
|&mdash;&mdash;&mdash;&mdash;&gt;mod.rs
|&mdash;&mdash;&mdash;&mdash;&gt;tcp.rs
|&mdash;&mdash;&mdash;&mdash;&gt;udp.rs
|&mdash;&mdash;&ndash;&gt;sys						//不同系统下的实现
|&mdash;&mdash;&mdash;&mdash;&gt;mod.rs		
|&mdash;&mdash;&mdash;&mdash;&gt;fuchsia
|&mdash;&mdash;&mdash;&mdash;&gt;unix				//Linux下封装的epoll
|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&gt;mod.rs
|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&gt;epoll.rs						【3】
|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&gt;awakener.rs
|&mdash;&mdash;&mdash;&mdash;&gt;windows			//windows下封装的iocp
|&mdash;&mdash;&ndash;&gt;lib.rs
|&mdash;&mdash;&ndash;&gt;poll.rs			//定义Poll			【2】
|&mdash;&mdash;&ndash;&gt;channel.rs		【4】
|&mdash;&mdash;&ndash;&gt;event_imp.rs
|&mdash;&mdash;&ndash;&gt;timer.rs		【5】
|&mdash;&mdash;&ndash;&gt;&hellip;&hellip;
对涉及不同操作系统的部分代码，以Linux操作系统为例。在Linux操作系统中，mio封装了epoll。后面会给出相应的代码。</p>
<p>【1】Eventloop代码分析
结合前面的代码示例给出相应的关键代码如下：</p>
<p>EventLoop事件循环定义，可以看到里面封装了Poll，以Linux系统举例，Poll又封装了epoll。在使用Poll或Linux中epoll时，最重要的代码是epoll_wait()等待事件Event并针对每个Event进行不同的处理。这里EventLoop将epoll_create()、epoll_wait()、epoll_ctl()进行进一步的封装，将对Event的处理抽象成Handler，供上层实现具体的逻辑处理。</p>
<p>// Single threaded IO event loop.		//这里是单线程事件循环，更多的时候我们需要加线程池，以此为基础，再进行一次封装，供上层使用
pub struct EventLoop&lt;H: Handler&gt; {
run: bool,
poll: Poll,	
events: Events,		//对应epoll中的epoll_event
timer: Timer&lt;H::Timeout&gt;,
notify_tx: channel::SyncSender&lt;H::Message&gt;,
notify_rx: channel::Receiver&lt;H::Message&gt;,
config: Config,
}
抽象出接口供上层应用实现不同事件的逻辑处理。这里有点类似于回调函数，上层用户需要在此实现业务逻辑代码，实际运行时需要将函数指针传递给底层事件循环，底层事件循环运行时会调用用户传递过来的函数。在Rust中，可能描述的不是很精准，不过可以这样理解。</p>
<p>pub trait Handler: Sized {
type Timeout;
type Message;</p>
<pre><code>/// Invoked when the socket represented by `token` is ready to be operated
/// on. `events` indicates the specific operations that are
/// ready to be performed.
/// This function will only be invoked a single time per socket per event
/// loop tick.
fn ready(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, token: Token, events: Ready) {
}		//【1】

/// Invoked when a message has been received via the event loop's channel.
fn notify(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, msg: Self::Message) {
}		//【2】

/// Invoked when a timeout has completed.
fn timeout(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, timeout: Self::Timeout) {
}		//【3】

/// Invoked when `EventLoop` has been interrupted by a signal interrupt.
fn interrupted(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) {
}		//【4】

/// Invoked at the end of an event loop tick.
fn tick(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) {
}		//【5】
</code></pre>
<p>}
这里把Poll进行了封装，主要实现了Eventloop::new()&mdash;-&gt;Poll::new()&mdash;-&gt;epoll_create()，Eventloop::run()—&gt;Selecter::select()&mdash;-&gt;epoll_wait()，还有register()、reregister()、deregister()等等…</p>
<p>impl&lt;H: Handler&gt; EventLoop<!-- raw HTML omitted --> {
/// Constructs a new <code>EventLoop</code> using the default configuration values.
/// The <code>EventLoop</code> will not be running.
pub fn new() -&gt; io::Result&lt;EventLoop<!-- raw HTML omitted -->&gt; {
EventLoop::configured(Config::default())
}</p>
<pre><code>fn configured(config: Config) -&gt; io::Result&lt;EventLoop&lt;H&gt;&gt; {
    // Create the IO poller
    let poll = Poll::new()?;		//Linux内部调用epoll_create()

    let timer = timer::Builder::default()
        .tick_duration(config.timer_tick)
        .num_slots(config.timer_wheel_size)
        .capacity(config.timer_capacity)
        .build();

    // Create cross thread notification queue
    let (tx, rx) = channel::sync_channel(config.notify_capacity);  //这里创建的是同步管道,可配置同步管道内部的buffer queue bound size.

    // Register the notification wakeup FD with the IO poller
    poll.register(&amp;rx, NOTIFY, Ready::readable(), PollOpt::edge() | PollOpt::oneshot())?;	//NOTIFY和TIMER由mio实现
    poll.register(&amp;timer, TIMER, Ready::readable(), PollOpt::edge())?;

    Ok(EventLoop {
        run: true,
        poll: poll,
        timer: timer,
        notify_tx: tx,
        notify_rx: rx,
        config: config,
        events: Events::with_capacity(1024),
    })
}

/// Keep spinning the event loop indefinitely, and notify the handler whenever
/// any of the registered handles are ready.
pub fn run(&amp;mut self, handler: &amp;mut H) -&gt; io::Result&lt;()&gt; {
    self.run = true;

    while self.run {
        // Execute ticks as long as the event loop is running
        self.run_once(handler, None)?;	//Linux下调用epoll_wait()
    }

    Ok(())
}

pub fn run_once(&amp;mut self, handler: &amp;mut H, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;()&gt; {
    trace!(&quot;event loop tick&quot;);

    // Check the registered IO handles for any new events. Each poll
    // is for one second, so a shutdown request can last as long as
    // one second before it takes effect.
    let events = match self.io_poll(timeout) {
        Ok(e) =&gt; e,
        Err(err) =&gt; {
            if err.kind() == io::ErrorKind::Interrupted {
                handler.interrupted(self);		//调用Handler::interrupted() 【4】
                0
            } else {
                return Err(err);
            }
        }
    };

    self.io_process(handler, events);	//处理就绪的事件，handler为如何处理各种事件的实例
    handler.tick(self);	//一轮事件处理后，最后调用Handler::tick()	调用【5】
    Ok(())
}

#[inline]
fn io_poll(&amp;mut self, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;usize&gt; {
    self.poll.poll(&amp;mut self.events, timeout)
}

// Process IO events that have been previously polled
fn io_process(&amp;mut self, handler: &amp;mut H, cnt: usize) {
    let mut i = 0;

    trace!(&quot;io_process(..); cnt={}; len={}&quot;, cnt, self.events.len());

    // Iterate over the notifications. Each event provides the token
    // it was registered with (which usually represents, at least, the
    // handle that the event is about) as well as information about
    // what kind of event occurred (readable, writable, signal, etc.)
    while i &lt; cnt {		//遍历所有就绪的事件，进行处理
        let evt = self.events.get(i).unwrap();

        trace!(&quot;event={:?}; idx={:?}&quot;, evt, i);

		// mio在epoll之上，增加了NOTIFY和TIMER
        match evt.token() {
            NOTIFY =&gt; self.notify(handler),			//channel处理 ，这个epoll中是没有的，mio实现
            TIMER =&gt; self.timer_process(handler),	//Timer处理， 这个epoll中也是没有的，mio实现
            _ =&gt; self.io_event(handler, evt)		//IO事件的处理， 这个epoll有
        }

        i += 1;
    }
}

fn io_event(&amp;mut self, handler: &amp;mut H, evt: Event) {
    handler.ready(self, evt.token(), evt.readiness());	//调用Handler::ready() 【1】
}

fn notify(&amp;mut self, handler: &amp;mut H) {
    for _ in 0..self.config.messages_per_tick {
        match self.notify_rx.try_recv() {	//从channel中接收数据，内部实现是std::sync::mpsc::sync_channel()
            Ok(msg) =&gt; handler.notify(self, msg),	//调用Handler::notify()	【2】
            _ =&gt; break,
        }
    }

    // Re-register
    let _ = self.poll.reregister(&amp;self.notify_rx, NOTIFY, Ready::readable(), PollOpt::edge() | PollOpt::oneshot());	//PollOpt::oneshot(),必须重新reregister.
}

fn timer_process(&amp;mut self, handler: &amp;mut H) {
    while let Some(t) = self.timer.poll() {
        handler.timeout(self, t);	//调用Handler::timeout() 【3】
    }
}

/// Registers an IO handle with the event loop.
pub fn register&lt;E: ?Sized&gt;(&amp;mut self, io: &amp;E, token: Token, interest: Ready, opt: PollOpt) -&gt; io::Result&lt;()&gt;
    where E: Evented
{
    self.poll.register(io, token, interest, opt)
}

/// Re-Registers an IO handle with the event loop.
pub fn reregister&lt;E: ?Sized&gt;(&amp;mut self, io: &amp;E, token: Token, interest: Ready, opt: PollOpt) -&gt; io::Result&lt;()&gt;
    where E: Evented
{
    self.poll.reregister(io, token, interest, opt)
}

/// Deregisters an IO handle with the event loop.
pub fn deregister&lt;E: ?Sized&gt;(&amp;mut self, io: &amp;E) -&gt; io::Result&lt;()&gt; where E: Evented {
    self.poll.deregister(io)
}

/// Returns a sender that allows sending messages to the event loop in a
/// thread-safe way, waking up the event loop if needed.
pub fn channel(&amp;self) -&gt; Sender&lt;H::Message&gt; {
    Sender::new(self.notify_tx.clone())
}

/// Schedules a timeout after the requested time interval. When the
/// duration has been reached,
pub fn timeout(&amp;mut self, token: H::Timeout, delay: Duration) -&gt; timer::Result&lt;Timeout&gt; {
    self.timer.set_timeout(delay, token)
}

/// If the supplied timeout has not been triggered, cancel it such that it
/// will not be triggered in the future.
pub fn clear_timeout(&amp;mut self, timeout: &amp;Timeout) -&gt; bool {
    self.timer.cancel_timeout(&amp;timeout).is_some()
}

/// Tells the event loop to exit after it is done handling all events in the current iteration.
pub fn shutdown(&amp;mut self) {
    self.run = false;
}

/// Indicates whether the event loop is currently running. If it's not it has either
/// stopped or is scheduled to stop on the next tick.
pub fn is_running(&amp;self) -&gt; bool {
    self.run
}
</code></pre>
<p>}
【2】Poll代码分析
Poll屏蔽了不同系统的实现，给出了统一的抽象。Poll的实现代码这里只能列出较为重要的部分代码，有一部分代码省略掉了，详细代码可查看mio/src/poll.rs：</p>
<p>pub struct Poll {
// Platform specific IO selector
selector: sys::Selector,</p>
<pre><code>// Custom readiness queue
// The second readiness queue is implemented in user space by `ReadinessQueue`. It provides a way to implement purely user space `Evented` types.
readiness_queue: ReadinessQueue,	//区别于系统就绪队列（sys::Selector），这是上层自己实现的就绪队列

// Use an atomic to first check if a full lock will be required. This is a
// fast-path check for single threaded cases avoiding the extra syscall
lock_state: AtomicUsize,

// Sequences concurrent calls to `Poll::poll`
lock: Mutex&lt;()&gt;,

// Wakeup the next waiter
condvar: Condvar,
</code></pre>
<p>}</p>
<p>impl Poll {
/// Return a new <code>Poll</code> handle.
pub fn new() -&gt; io::Result<!-- raw HTML omitted --> {
is_send::<!-- raw HTML omitted -->();
is_sync::<!-- raw HTML omitted -->();</p>
<pre><code>    let poll = Poll {
        selector: sys::Selector::new()?,
        readiness_queue: ReadinessQueue::new()?,
        lock_state: AtomicUsize::new(0),
        lock: Mutex::new(()),
        condvar: Condvar::new(),
    };

    // Register the notification wakeup FD with the IO poller
    poll.readiness_queue.inner.awakener.register(&amp;poll, AWAKEN, Ready::readable(), PollOpt::edge())?;

    Ok(poll)
}

/// Wait for readiness events
///
/// Blocks the current thread and waits for readiness events for any of the
/// `Evented` handles that have been registered with this `Poll` instance.
/// The function will block until either at least one readiness event has
/// been received or `timeout` has elapsed. A `timeout` of `None` means that
/// `poll` will block until a readiness event has been received.
pub fn poll(&amp;self, events: &amp;mut Events, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;usize&gt; {
    self.poll1(events, timeout, false)		//Poll::poll()非常最重要的一个方法， poll()--&gt;poll1()--&gt;poll2()
}

fn poll1(&amp;self, events: &amp;mut Events, mut timeout: Option&lt;Duration&gt;, interruptible: bool) -&gt; io::Result&lt;usize&gt; {
    let zero = Some(Duration::from_millis(0));

    let mut curr = self.lock_state.compare_and_swap(0, 1, SeqCst);

    if 0 != curr { ... }	//{ ... }代表中间有很多代码被省略掉了.

    let ret = self.poll2(events, timeout, interruptible);

    // Release the lock
    if 1 != self.lock_state.fetch_and(!1, Release) { ... }	//{ ... }代表中间有很多代码被省略掉了.

    ret
}

#[inline]
fn poll2(&amp;self, events: &amp;mut Events, mut timeout: Option&lt;Duration&gt;, interruptible: bool) -&gt; io::Result&lt;usize&gt; {
    // Compute the timeout value passed to the system selector. If the
    // readiness queue has pending nodes, we still want to poll the system
    // selector for new events, but we don't want to block the thread to
    // wait for new events.
    if timeout == Some(Duration::from_millis(0)) {
        // If blocking is not requested, then there is no need to prepare
        // the queue for sleep
        //
        // The sleep_marker should be removed by readiness_queue.poll().
    } else if self.readiness_queue.prepare_for_sleep() {
        // The readiness queue is empty. The call to `prepare_for_sleep`
        // inserts `sleep_marker` into the queue. This signals to any
        // threads setting readiness that the `Poll::poll` is going to
        // sleep, so the awakener should be used.
    } else {
        // The readiness queue is not empty, so do not block the thread.
        timeout = Some(Duration::from_millis(0));
    }

	//poll系统就绪队列
    loop {
        let now = Instant::now();
        // First get selector events
        let res = self.selector.select(&amp;mut events.inner, AWAKEN, timeout);	//Linux下调用epoll_wait(),就绪事件放入events中
        match res {
            Ok(true) =&gt; {
                // Some awakeners require reading from a FD.
                self.readiness_queue.inner.awakener.cleanup();
                break;
            }
            Ok(false) =&gt; break,
            Err(ref e) if e.kind() == io::ErrorKind::Interrupted &amp;&amp; !interruptible =&gt; {
                // Interrupted by a signal; update timeout if necessary and retry
                if let Some(to) = timeout {
                    let elapsed = now.elapsed();
                    if elapsed &gt;= to {
                        break;
                    } else {
                        timeout = Some(to - elapsed);
                    }
                }
            }
            Err(e) =&gt; return Err(e),
        }
    }

    // Poll custom event queue
    self.readiness_queue.poll(&amp;mut events.inner);	//Poll用户就绪队列

    // Return number of polled events
    Ok(events.inner.len())
}

/// Register an `Evented` handle with the `Poll` instance.
pub fn register&lt;E: ?Sized&gt;(&amp;self, handle: &amp;E, token: Token, interest: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt;
    where E: Evented {
    validate_args(token)?;

    // Register interests for this socket
    handle.register(self, token, interest, opts)?;

    Ok(())
}

/// Re-register an `Evented` handle with the `Poll` instance.
pub fn reregister&lt;E: ?Sized&gt;(&amp;self, handle: &amp;E, token: Token, interest: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt;
    where E: Evented {
    validate_args(token)?;

    // Register interests for this socket
    handle.reregister(self, token, interest, opts)?;

    Ok(())
}

/// Deregister an `Evented` handle with the `Poll` instance.
pub fn deregister&lt;E: ?Sized&gt;(&amp;self, handle: &amp;E) -&gt; io::Result&lt;()&gt;
    where E: Evented {
    // Deregister interests for this socket
    handle.deregister(self)?;

    Ok(())
}
</code></pre>
<p>}
【3】Selector代码分析
下面这段代码出自mio/src/sys/unix/epoll.rs是对底层Linux系统epoll的封装抽象，可以看到Selector::new()内部实际上调用了epoll_create()，Selector::select()内部实际上调用了epoll_wait()，register()、reregister()、deregister()实内部实际上调用了epoll_ctl()。如果你非常熟悉epoll，就会感觉下面的代码很熟悉，详细代码如下：</p>
<p>pub struct Selector {
id: usize,
epfd: RawFd,
}</p>
<p>impl Selector {
pub fn new() -&gt; io::Result<!-- raw HTML omitted --> {
let epfd = unsafe {
// Emulate <code>epoll_create</code> by using <code>epoll_create1</code> if it&rsquo;s available
// and otherwise falling back to <code>epoll_create</code> followed by a call to
// set the CLOEXEC flag.
dlsym!(fn epoll_create1(c_int) -&gt; c_int);</p>
<pre><code>        match epoll_create1.get() {
            Some(epoll_create1_fn) =&gt; {
                cvt(epoll_create1_fn(libc::EPOLL_CLOEXEC))?
            }
            None =&gt; {
                let fd = cvt(libc::epoll_create(1024))?;
                drop(set_cloexec(fd));
                fd
            }
        }
    };

    // offset by 1 to avoid choosing 0 as the id of a selector
    let id = NEXT_ID.fetch_add(1, Ordering::Relaxed) + 1;

    Ok(Selector {
        id: id,
        epfd: epfd,
    })
}

pub fn id(&amp;self) -&gt; usize {
    self.id
}

/// Wait for events from the OS
pub fn select(&amp;self, evts: &amp;mut Events, awakener: Token, timeout: Option&lt;Duration&gt;) -&gt; io::Result&lt;bool&gt; {
    let timeout_ms = timeout
        .map(|to| cmp::min(millis(to), i32::MAX as u64) as i32)
        .unwrap_or(-1);

    // Wait for epoll events for at most timeout_ms milliseconds
    evts.clear();
    unsafe {
        let cnt = cvt(libc::epoll_wait(self.epfd,
                                       evts.events.as_mut_ptr(),
                                       evts.events.capacity() as i32,
                                       timeout_ms))?;
        let cnt = cnt as usize;
        evts.events.set_len(cnt);

        for i in 0..cnt {
            if evts.events[i].u64 as usize == awakener.into() {
                evts.events.remove(i);
                return Ok(true);
            }
        }
    }

    Ok(false)
}

/// Register event interests for the given IO handle with the OS
pub fn register(&amp;self, fd: RawFd, token: Token, interests: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt; {
    let mut info = libc::epoll_event {
        events: ioevent_to_epoll(interests, opts),
        u64: usize::from(token) as u64
    };

    unsafe {
        cvt(libc::epoll_ctl(self.epfd, libc::EPOLL_CTL_ADD, fd, &amp;mut info))?;
        Ok(())
    }
}

/// Register event interests for the given IO handle with the OS
pub fn reregister(&amp;self, fd: RawFd, token: Token, interests: Ready, opts: PollOpt) -&gt; io::Result&lt;()&gt; {
    let mut info = libc::epoll_event {
        events: ioevent_to_epoll(interests, opts),
        u64: usize::from(token) as u64
    };

    unsafe {
        cvt(libc::epoll_ctl(self.epfd, libc::EPOLL_CTL_MOD, fd, &amp;mut info))?;
        Ok(())
    }
}

/// Deregister event interests for the given IO handle with the OS
pub fn deregister(&amp;self, fd: RawFd) -&gt; io::Result&lt;()&gt; {
    // The &amp;info argument should be ignored by the system,
    // but linux &lt; 2.6.9 required it to be not null.
    // For compatibility, we provide a dummy EpollEvent.
    let mut info = libc::epoll_event {
        events: 0,
        u64: 0,
    };

    unsafe {
        cvt(libc::epoll_ctl(self.epfd, libc::EPOLL_CTL_DEL, fd, &amp;mut info))?;
        Ok(())
    }
}
</code></pre>
<p>}
【4】Notify channel代码分析
这个涉及的代码比较多，比较杂，也较为难以理解。</p>
<p>// <code>ReadinessQueue</code> is backed by a MPSC queue that supports reuse of linked
// list nodes. This significantly reduces the number of required allocations.
// Each <code>Registration</code> / <code>SetReadiness</code> pair allocates a single readiness node
// that is used for the lifetime of the registration.
//
// The readiness node also includes a single atomic variable, <code>state</code> that
// tracks most of the state associated with the registration. This includes the
// current readiness, interest, poll options, and internal state. When the node
// state is mutated, it is queued in the MPSC channel. A call to
// <code>ReadinessQueue::poll</code> will dequeue and process nodes. The node state can
// still be mutated while it is queued in the channel for processing.
// Intermediate state values do not matter as long as the final state is
// included in the call to <code>poll</code>. This is the eventually consistent nature of
// the readiness queue.
//
// The readiness node is ref counted using the <code>ref_count</code> field. On creation,
// the ref_count is initialized to 3: one <code>Registration</code> handle, one
// <code>SetReadiness</code> handle, and one for the readiness queue. Since the readiness queue
// doesn&rsquo;t <em>always</em> hold a handle to the node, we don&rsquo;t use the Arc type for
// managing ref counts (this is to avoid constantly incrementing and
// decrementing the ref count when pushing &amp; popping from the queue). When the
// <code>Registration</code> handle is dropped, the <code>dropped</code> flag is set on the node, then
// the node is pushed into the registration queue. When Poll::poll pops the
// node, it sees the drop flag is set, and decrements it&rsquo;s ref count.
//
// The MPSC queue is a modified version of the intrusive MPSC node based queue
// described by 1024cores [1].
#[derive(Clone)]
struct ReadinessQueue {
inner: Arc<!-- raw HTML omitted -->,
}</p>
<p>struct ReadinessQueueInner {
// Used to wake up <code>Poll</code> when readiness is set in another thread.
awakener: sys::Awakener,</p>
<pre><code>// Head of the MPSC queue used to signal readiness to `Poll::poll`.
head_readiness: AtomicPtr&lt;ReadinessNode&gt;,

// Tail of the readiness queue.
//
// Only accessed by Poll::poll. Coordination will be handled by the poll fn
tail_readiness: UnsafeCell&lt;*mut ReadinessNode&gt;,

// Fake readiness node used to punctuate the end of the readiness queue.
// Before attempting to read from the queue, this node is inserted in order
// to partition the queue between nodes that are &quot;owned&quot; by the dequeue end
// and nodes that will be pushed on by producers.
end_marker: Box&lt;ReadinessNode&gt;,

// Similar to `end_marker`, but this node signals to producers that `Poll`
// has gone to sleep and must be woken up.
sleep_marker: Box&lt;ReadinessNode&gt;,

// Similar to `end_marker`, but the node signals that the queue is closed.
// This happens when `ReadyQueue` is dropped and signals to producers that
// the nodes should no longer be pushed into the queue.
closed_marker: Box&lt;ReadinessNode&gt;,
</code></pre>
<p>}
/// Node shared by a <code>Registration</code> / <code>SetReadiness</code> pair as well as the node
/// queued into the MPSC channel.
struct ReadinessNode {
// Node state, see struct docs for <code>ReadinessState</code>
//
// This variable is the primary point of coordination between all the
// various threads concurrently accessing the node.
state: AtomicState,</p>
<pre><code>// The registration token cannot fit into the `state` variable, so it is
// broken out here. In order to atomically update both the state and token
// we have to jump through a few hoops.
//
// First, `state` includes `token_read_pos` and `token_write_pos`. These can
// either be 0, 1, or 2 which represent a token slot. `token_write_pos` is
// the token slot that contains the most up to date registration token.
// `token_read_pos` is the token slot that `poll` is currently reading from.
//
// When a call to `update` includes a different token than the one currently
// associated with the registration (token_write_pos), first an unused token
// slot is found. The unused slot is the one not represented by
// `token_read_pos` OR `token_write_pos`. The new token is written to this
// slot, then `state` is updated with the new `token_write_pos` value. This
// requires that there is only a *single* concurrent call to `update`.
//
// When `poll` reads a node state, it checks that `token_read_pos` matches
// `token_write_pos`. If they do not match, then it atomically updates
// `state` such that `token_read_pos` is set to `token_write_pos`. It will
// then read the token at the newly updated `token_read_pos`.
token_0: UnsafeCell&lt;Token&gt;,
token_1: UnsafeCell&lt;Token&gt;,
token_2: UnsafeCell&lt;Token&gt;,

// Used when the node is queued in the readiness linked list. Accessing
// this field requires winning the &quot;queue&quot; lock
next_readiness: AtomicPtr&lt;ReadinessNode&gt;,

// Ensures that there is only one concurrent call to `update`.
//
// Each call to `update` will attempt to swap `update_lock` from `false` to
// `true`. If the CAS succeeds, the thread has obtained the update lock. If
// the CAS fails, then the `update` call returns immediately and the update
// is discarded.
update_lock: AtomicBool,

// Pointer to Arc&lt;ReadinessQueueInner&gt;
readiness_queue: AtomicPtr&lt;()&gt;,

// Tracks the number of `ReadyRef` pointers
ref_count: AtomicUsize,
</code></pre>
<p>}
/// Handle to a user space <code>Poll</code> registration.
///
/// <code>Registration</code> allows implementing [<code>Evented</code>] for types that cannot work
/// with the [system selector]. A <code>Registration</code> is always paired with a
/// <code>SetReadiness</code>, which allows updating the registration&rsquo;s readiness state.
/// When [<code>set_readiness</code>] is called and the <code>Registration</code> is associated with a
/// [<code>Poll</code>] instance, a readiness event will be created and eventually returned
/// by [<code>poll</code>].
pub struct Registration {
inner: RegistrationInner,
}
/// Updates the readiness state of the associated <code>Registration</code>.
#[derive(Clone)]
pub struct SetReadiness {
inner: RegistrationInner,
}
未完，待续…</p>
<p>参考文档：Intrusive MPSC node-based queue</p>
<p>【5】Timer定时器代码分析
pub struct Timer<!-- raw HTML omitted --> {
// Size of each tick in milliseconds
tick_ms: u64,
// Slab of timeout entries
entries: Slab&lt;Entry<!-- raw HTML omitted -->&gt;,
// Timeout wheel. Each tick, the timer will look at the next slot for
// timeouts that match the current tick.
wheel: Vec<!-- raw HTML omitted -->,
// Tick 0&rsquo;s time instant
start: Instant,
// The current tick
tick: Tick,
// The next entry to possibly timeout
next: Token,
// Masks the target tick to get the slot
mask: u64,
// Set on registration with Poll
inner: LazyCell<!-- raw HTML omitted -->,
}
未完，待续…</p>
<p>三、mio用法示例
下面的2个示例都很简单，其实直接看mio的测试代码mio/test/就好了，不用看下面的2个示例。</p>
<p>1、代码示例1
直接使用Poll示例如下：</p>
<p>#[macro_use]
extern crate log;
extern crate simple_logger;
extern crate mio;</p>
<p>use mio::*;
use mio::tcp::{TcpListener, TcpStream};
use std::io::{Read,Write};</p>
<p>fn main() {
simple_logger::init().unwrap();</p>
<pre><code>// Setup some tokens to allow us to identify which event is for which socket.
const SERVER: Token = Token(0);
const CLIENT: Token = Token(1);

let addr = &quot;127.0.0.1:12345&quot;.parse().unwrap();

// Setup the server socket
let server = TcpListener::bind(&amp;addr).unwrap();

// Create a poll instance
let poll = Poll::new().unwrap();

// Start listening for incoming connections
poll.register(&amp;server, SERVER, Ready::readable(), PollOpt::edge()).unwrap();

// Setup the client socket
let sock = TcpStream::connect(&amp;addr).unwrap();

// Register the socket
poll.register(&amp;sock, CLIENT, Ready::readable(), PollOpt::edge()).unwrap();

// Create storage for events
let mut events = Events::with_capacity(1024);

loop {
    poll.poll(&amp;mut events, None).unwrap();

    for event in events.iter() {
        match event.token() {
            SERVER =&gt; {
                // Accept and drop the socket immediately, this will close
                // the socket and notify the client of the EOF.
                let (stream,addr) = server.accept().unwrap();
                info!(&quot;Listener accept {:?}&quot;,addr);
            },
            CLIENT =&gt; {
                // The server just shuts down the socket, let's just exit
                // from our event loop.
                info!(&quot;client response.&quot;);
                return;
            },
            _ =&gt; unreachable!(),
        }
    }
}
</code></pre>
<p>}
通过上面的代码示例1，我们可以看到其用法与epoll非常相似。</p>
<p>2、代码示例2
上面的代码编程时较为麻烦，下面使用事件循环EventLoop的方式，代码能看起来更清晰一些（相对的）：</p>
<p>#[macro_use]
extern crate log;
extern crate simple_logger;
extern crate mio;</p>
<p>use mio::*;
use mio::timer::{Timeout};
use mio::deprecated::{EventLoop, Handler, Sender, EventLoopBuilder};
use std::thread;
use std::time::Duration;</p>
<p>fn main() {
simple_logger::init().unwrap();</p>
<pre><code>let mut event_loop=EventLoop::new().unwrap();
let channel_sender=event_loop.channel();

thread::spawn(move ||{
    channel_sender.send(IoMessage::Notify);
    thread::sleep_ms(5*1000);
    channel_sender.send(IoMessage::End);
});

let timeout = event_loop.timeout(Token(123), Duration::from_millis(3000)).unwrap();

let mut handler=MioHandler::new();
let _ = event_loop.run(&amp;mut handler).unwrap();
</code></pre>
<p>}</p>
<p>pub enum IoMessage{
Notify,
End,
}</p>
<p>pub struct MioHandler{
}</p>
<p>impl MioHandler{
pub fn new()-&gt;Self{
MioHandler{}
}
}</p>
<p>impl Handler for MioHandler {
type Timeout = Token;
type Message = IoMessage;</p>
<pre><code>/// Invoked when the socket represented by `token` is ready to be operated on.
fn ready(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, token: Token, events: Ready) {
}

/// Invoked when a message has been received via the event loop's channel.
fn notify(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, msg: Self::Message) {
    match msg {
        IoMessage::Notify=&gt;info!(&quot;channel notify&quot;),
        IoMessage::End=&gt;{
            info!(&quot;shutdown eventloop.&quot;);
            event_loop.shutdown();
        }
    }
}

/// Invoked when a timeout has completed.
fn timeout(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;, timeout: Self::Timeout) {
    match timeout{
        Token(123)=&gt;info!(&quot;time out.&quot;),
        Token(_)=&gt;{},
    }
}

/// Invoked when `EventLoop` has been interrupted by a signal interrupt.
fn interrupted(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) {
}

/// Invoked at the end of an event loop tick.
fn tick(&amp;mut self, event_loop: &amp;mut EventLoop&lt;Self&gt;) {
}
</code></pre>
<p>}
这个示例说明了超时及channel，围绕EventLoop编程，其实与上一个例子没有什么不同，只是EventLoop对Poll做了封装。</p>
<p>参考文档：
【譯】Tokio 內部機制：從頭理解 Rust 非同步 I/O 框架
使用mio开发web framework - base
My Basic Understanding of mio and Asynchronous IO
MIO for Rust
mio-github</p>

                                </article>
                            
                        
                    
                        
                            
                                <article id="vw5pdhk6okdd55qe5a6e546w">
                                    <h2 class="major">Unity::GC的实现</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h1 id="gc的实现">GC的实现</h1>
<h2 id="实现gc的策略有很多种其中最常见一种就是-tracing-garbage-collection或者叫-mark-sweep这种算法会通过一个-root-object遍历这个该对象引用的变量并且标记递归这个过程这样就确定了所有reachable的对象剩下的对象即视为garbage">实现GC的策略有很多种，其中最常见一种就是 Tracing garbage collection，或者叫 Mark-Sweep，这种算法会通过一个 root Object，遍历这个该对象引用的变量，并且标记，递归这个过程，这样就确定了所有reachable的对象，剩下的对象即视为garbage。</h2>
<h2 id="heading"></h2>
<h2 id="另一种常见的策略还有引用计数reference-counting它是通过为每个对象维护一个引用计数这代表当前对该对象的引用数目当引用为0即代表该对象为-garage引用技术有如下缺点">另一种常见的策略还有引用计数（Reference counting），它是通过为每个对象维护一个引用计数，这代表当前对该对象的引用数目，当引用为0，即代表该对象为 Garage。引用技术有如下缺点</h2>
<h2 id="heading-1"></h2>
<h2 id="循环引用问题">循环引用问题</h2>
<h2 id="保存计数带来的空间开销">保存计数带来的空间开销</h2>
<h2 id="修改引用数目带来的速度开销以及原子性要求">修改引用数目带来的速度开销以及原子性要求</h2>
<h2 id="非实时一个引用的变化可能递归得导致一系列引用修改内存释放">非实时（一个引用的变化可能递归得导致一系列引用修改，内存释放)</h2>
<h2 id="有很多算法可以一定程度解决上述问题顺便一提c使用的智能指针即是基于引用计数实现的com对象也使用了引用计数来管理">有很多算法可以一定程度解决上述问题，顺便一提，C++使用的智能指针即是基于引用计数实现的，COM对象也使用了引用计数来管理。</h2>
<h1 id="unity-中的gc">Unity 中的GC</h1>
<h2 id="unity的脚本后端是基于mono的实现当然现在多了个il2cpp不过也是类似的gc实现而mono使用的gc是所谓的boehmdemersweiser-garbage-collector是mark-sweep-的实现它会在需要进行gc时占用主线程进行遍历-标记-垃圾回收的过程然后在归还主线程控制权这会导致帧数的突然下降产生卡顿不过因为该实现是非压缩式的所以卡顿现象相对较轻但是对内存利用率进一步下降了会有内存碎片的问题囧所以我们需要慎重地处理对象的创建内存请求还有释放使用gc管理内存是没有主动释放内存的接口的但是我们可以通过消除对某个对象的引用来做到这一点此外unity的代码分为两部分托管与非托管gc影响的只有托管部分的代码使用的堆内存而且这个托管堆占用的地址空间不会返还给操作系统">Unity的脚本后端是基于Mono的实现（当然现在多了个IL2CPP，不过也是类似的GC实现)，而Mono使用的GC是所谓的Boehm–Demers–Weiser garbage collector。是Mark-Sweep 的实现，它会在需要进行GC时占用主线程，进行遍历-标记-垃圾回收的过程，然后在归还主线程控制权。这会导致帧数的突然下降，产生卡顿（不过因为该实现是非压缩式的，所以卡顿现象相对较轻，但是对内存利用率进一步下降了，会有内存碎片的问题。。囧）。所以我们需要慎重地处理对象的创建（内存请求），还有释放（使用GC管理内存是没有主动释放内存的接口的，但是我们可以通过消除对某个对象的引用来做到这一点）。此外，Unity的代码分为两部分：托管与非托管，GC影响的只有托管部分的代码使用的堆内存。而且这个托管堆占用的地址空间不会返还给操作系统。。</h2>

                                </article>
                            
                        
                    
                        
                            
                                <article id="5l2g5aw977ym5liw55wm">
                                    <h2 class="major">你好，世界</h2>
                                    <span class="image main"><img src="" alt="" /></span>
                                    <h2>{{ page.title }}</h2>
<p>我的第一篇文章</p>
<p>{{ page.date | date_to_string }}</p>

                                </article>
                            
                        
                    

                </div>

                
<footer id="footer">
    <p class="copyright">&copy; Design: <a href="https://github.com/d-asnaghi">d-asnaghi</a> and <a href="https://html5up.net">HTML5 UP</a>.</p>
</footer>

        </div>

    
    <div id="bg"></div>

</body>


    
    <script src=http://example.org/assets/js/jquery.min.js></script>
    <script src=http://example.org/assets/js/browser.min.js></script>
    <script src=http://example.org/assets/js/breakpoints.min.js></script>
    <script src=http://example.org/assets/js/util.js></script>
    <script src=http://example.org/assets/js/main.js></script>

</html>
