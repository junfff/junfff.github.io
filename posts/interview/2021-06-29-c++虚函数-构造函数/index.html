<!doctype html>
<html lang="en-us">
  <head>
    <title>Interview::C&#43;&#43;虚函数-构造函数 // junfff blog </title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.98.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="http://example.org/css/main.min.4a7ec8660f9a44b08c4da97c5f2e31b1192df1d4d0322e65c0dbbc6ecb1b863f.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Interview::C&#43;&#43;虚函数-构造函数"/>
<meta name="twitter:description" content="Subject C&#43;&#43; 构造函数可以是虚函数吗？ 析构函数可以是虚函数吗？   1.构造函数不能为虚函数
  当我们将构造函数定义为虚函数时,会直接报错:
  首先回忆下以前学的virtual虚函数概念:
  如果类定义了虚函数,创建对象时,则会分配内存空间,并且为该父类以及其所有子类的内存空间上额外分配一个虚函数表.
  虚函数表的作用在于,存储每个类的相同的虚函数名,然后每一次虚函数调用,都会去虚函数表查找地址
  分析:
  假如构造函数是虚函数的话,由于对象开始还未分配内存空间,所以根本就无法找到虚函数表,从而构造函数也无法被调用.所以构造函数是不能成为虚函数.
  2.析构函数可以为虚函数
  首先回忆下析构函数:
  当某个内对象被注销时,编译器会自动顺序调用该类以及其父类的析构函数,而不会调用派生类的析构函数.
  虚析构函数的好处
  假如我们通过派生类生成基类对象时,如果析构函数是虚函数,则我们释放其基类对象时,能使整个类(包括派生类)对象完全释放,如果析构函数只是普通函数,则不能析构完全.
  分析:
  所以当我们在用多态的时候(通过基类来调用派生类成员函数),析构函数最好为虚函数
  #include using namespace std;
class ClassBase { public: ClassBase(){}; virtual ~ClassBase() { cout&laquo;&quot;~ClassBase()&quot;&laquo;endl; }
virtual void func() //虚函数成员 { cout&lt;&lt;&quot;ClassBase: func()&quot;&lt;&lt;endl; }  };"/>

    <meta property="og:title" content="Interview::C&#43;&#43;虚函数-构造函数" />
<meta property="og:description" content="Subject C&#43;&#43; 构造函数可以是虚函数吗？ 析构函数可以是虚函数吗？   1.构造函数不能为虚函数
  当我们将构造函数定义为虚函数时,会直接报错:
  首先回忆下以前学的virtual虚函数概念:
  如果类定义了虚函数,创建对象时,则会分配内存空间,并且为该父类以及其所有子类的内存空间上额外分配一个虚函数表.
  虚函数表的作用在于,存储每个类的相同的虚函数名,然后每一次虚函数调用,都会去虚函数表查找地址
  分析:
  假如构造函数是虚函数的话,由于对象开始还未分配内存空间,所以根本就无法找到虚函数表,从而构造函数也无法被调用.所以构造函数是不能成为虚函数.
  2.析构函数可以为虚函数
  首先回忆下析构函数:
  当某个内对象被注销时,编译器会自动顺序调用该类以及其父类的析构函数,而不会调用派生类的析构函数.
  虚析构函数的好处
  假如我们通过派生类生成基类对象时,如果析构函数是虚函数,则我们释放其基类对象时,能使整个类(包括派生类)对象完全释放,如果析构函数只是普通函数,则不能析构完全.
  分析:
  所以当我们在用多态的时候(通过基类来调用派生类成员函数),析构函数最好为虚函数
  #include using namespace std;
class ClassBase { public: ClassBase(){}; virtual ~ClassBase() { cout&laquo;&quot;~ClassBase()&quot;&laquo;endl; }
virtual void func() //虚函数成员 { cout&lt;&lt;&quot;ClassBase: func()&quot;&lt;&lt;endl; }  };" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://example.org/posts/interview/2021-06-29-c&#43;&#43;%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/" /><meta property="article:section" content="posts" />





  </head>
  <body>
    <header class="app-header">
      <a href="http://example.org/"><img class="app-header-avatar" src="/avatar.jpg" alt="John Doe" /></a>
      <h1>junfff blog </h1>
      <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nunc vehicula turpis sit amet elit pretium.</p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">Interview::C&#43;&#43;虚函数-构造函数</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 1, 0001
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="http://example.org/tags/interview/">Interview</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <h1 id="subject--c-构造函数可以是虚函数吗-析构函数可以是虚函数吗">Subject  C++ 构造函数可以是虚函数吗？ 析构函数可以是虚函数吗？</h1>
<ul>
<li>
<p>1.构造函数不能为虚函数</p>
<ul>
<li>
<p>当我们将构造函数定义为虚函数时,会直接报错:</p>
</li>
<li>
<p>首先回忆下以前学的virtual虚函数概念:</p>
</li>
<li>
<p>如果类定义了虚函数,创建对象时,则会分配内存空间,并且为该父类以及其所有子类的内存空间上额外分配一个虚函数表.</p>
</li>
<li>
<p>虚函数表的作用在于,存储每个类的相同的虚函数名,然后每一次虚函数调用,都会去虚函数表查找地址</p>
</li>
<li>
<p>分析:</p>
</li>
<li>
<p>假如构造函数是虚函数的话,由于对象开始还未分配内存空间,所以根本就无法找到虚函数表,从而构造函数也无法被调用.所以构造函数是不能成为虚函数.</p>
</li>
<li>
<p>2.析构函数可以为虚函数</p>
</li>
<li>
<p>首先回忆下析构函数:</p>
</li>
<li>
<p>当某个内对象被注销时,编译器会自动顺序调用该类以及其父类的析构函数,而不会调用派生类的析构函数.</p>
</li>
<li>
<p>虚析构函数的好处</p>
</li>
<li>
<p>假如我们通过派生类生成基类对象时,如果析构函数是虚函数,则我们释放其基类对象时,能使整个类(包括派生类)对象完全释放,如果析构函数只是普通函数,则不能析构完全.</p>
</li>
<li>
<p>分析:</p>
</li>
<li>
<p>所以当我们在用多态的时候(通过基类来调用派生类成员函数),析构函数最好为虚函数</p>
</li>
</ul>
<p>#include <!-- raw HTML omitted -->
using namespace std;</p>
<p>class ClassBase
{
public:
ClassBase(){};
virtual ~ClassBase()
{
cout&laquo;&quot;~ClassBase()&quot;&laquo;endl;
}</p>
<pre><code>virtual void func()                         //虚函数成员
{
    cout&lt;&lt;&quot;ClassBase: func()&quot;&lt;&lt;endl;
}
</code></pre>
<p>};</p>
<p>class ClassDerived : public ClassBase
{
public:
ClassDerived(){};
~ClassDerived()
{
cout&laquo;&quot;~ClassDerived()&quot;&laquo;endl;
}
void func()                    //虚函数成员
{
cout&laquo;&ldquo;ClassDerived: func()&quot;&laquo;endl;
}
};</p>
<p>int main()
{
ClassBase *p = new  ClassDerived;</p>
<pre><code> p-&gt;func();                   //通过多态来调用派生类虚函数

 delete p;

 return 0;
</code></pre>
<p>}</p>
<ul>
<li>
<p>打印如下:</p>
</li>
<li>
<p>ClassBase: func()</p>
</li>
<li>
<p>~ClassDerived()</p>
</li>
<li>
<p>~ClassBase()</p>
</li>
</ul>
</li>
</ul>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
