<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Interview on junfff blog </title>
    <link>http://example.org/tags/interview/</link>
    <description>Recent content in Interview on junfff blog </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="http://example.org/tags/interview/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Interview::C&#43;&#43;虚函数-构造函数</title>
      <link>http://example.org/posts/interview/2021-06-29-c&#43;&#43;%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/interview/2021-06-29-c&#43;&#43;%E8%99%9A%E5%87%BD%E6%95%B0-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>Subject C++ 构造函数可以是虚函数吗？ 析构函数可以是虚函数吗？ #    1.构造函数不能为虚函数
  当我们将构造函数定义为虚函数时,会直接报错:
  首先回忆下以前学的virtual虚函数概念:
  如果类定义了虚函数,创建对象时,则会分配内存空间,并且为该父类以及其所有子类的内存空间上额外分配一个虚函数表.
  虚函数表的作用在于,存储每个类的相同的虚函数名,然后每一次虚函数调用,都会去虚函数表查找地址
  分析:
  假如构造函数是虚函数的话,由于对象开始还未分配内存空间,所以根本就无法找到虚函数表,从而构造函数也无法被调用.所以构造函数是不能成为虚函数.
  2.析构函数可以为虚函数
  首先回忆下析构函数:
  当某个内对象被注销时,编译器会自动顺序调用该类以及其父类的析构函数,而不会调用派生类的析构函数.
  虚析构函数的好处
  假如我们通过派生类生成基类对象时,如果析构函数是虚函数,则我们释放其基类对象时,能使整个类(包括派生类)对象完全释放,如果析构函数只是普通函数,则不能析构完全.
  分析:
  所以当我们在用多态的时候(通过基类来调用派生类成员函数),析构函数最好为虚函数
  #include using namespace std;
class ClassBase { public: ClassBase(){}; virtual ~ClassBase() { cout&amp;laquo;&amp;quot;~ClassBase()&amp;quot;&amp;laquo;endl; }
virtual void func() //虚函数成员 { cout&amp;lt;&amp;lt;&amp;quot;ClassBase: func()&amp;quot;&amp;lt;&amp;lt;endl; }  };</description>
    </item>
    
    <item>
      <title>Interview::five-ball-select-two</title>
      <link>http://example.org/posts/interview/2021-06-26-five-ball-select-two/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/interview/2021-06-26-five-ball-select-two/</guid>
      <description>Subject #    从2个红球，2个黄球，1个白球中随机取出两个球，则两球颜色不同的概率是___．.
 从5个球中任意取两个共有C52=10种，两球颜色相同的有2种，两球颜色不同的概率是1-2/10=4/5， 故答案为：4/5． 根据互斥时间的概率公式计算即可． 本题考点：古典概型及其概率计算公式  考点点评： 本题考查了概率的基本性质和等可能事件的概率，求解方法采用了正难则反的原则，解答的关键是求出基本事件总数和发生事件的个数，属基本题型
  </description>
    </item>
    
    <item>
      <title>Interview::for-for-for</title>
      <link>http://example.org/posts/interview/2021-06-26-for-for-for/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/interview/2021-06-26-for-for-for/</guid>
      <description>Subject #   int a = 3; int b = 4; int c = 5; int x = 0; for (int i = 0; i &amp;lt; a; i++) { for (int j = 0; j &amp;lt; b; j++) { for (int k = 0; k &amp;lt; c; k++) { x++; } } } 任意断点 x 位置,根据 x 值 推断 i j k,求出公式。 x = 58 k = 58%5=3 , j = 58/5=11%4=3, i =11/4=2 x = 33 k = 33%5=3 , j = 33/5=6%4=2, i =6/4=1 公式： k=x%c,j=x/c%b, i=x/c/b  </description>
    </item>
    
    <item>
      <title>Interview::unity</title>
      <link>http://example.org/posts/interview/2021-06-29-unity/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>http://example.org/posts/interview/2021-06-29-unity/</guid>
      <description>Subject assetBundle.Unload true 和false 区别 #  - 当传入的参数为true，则不仅仅内存中的AssetBundle对象包含的资源会被销毁。根据这些资源实例化而来的游戏内的对象也会销毁。 - 当传入的参数为false，则仅仅销毁内存中的AssetBundle对象包含的资源。  Unity GC 机制 #  战场优化 #  模型预加载 动态图集 光效粒子 屏幕内外 自定义UIMesh GPU Instancing, 容器扩容优化，遍历容器，线程安全容器 #  寻路 A* B* #  物理碰撞,静态碰撞。动态碰撞RVO #  动态图集的优化原理是什么 #  所谓动态图集就是没有办法静态生成的，需要在运行时动态生成的图集，那么我们为什么需要动态图集？ #  动态图集是为了解决游戏中动态图片太多的问题，也就是我们没有办法预先放在UI上的。下图案例中可以看到右下角的英雄技能图标、天赋技能图标，以及主动使用的物品图片，均为动态加载。左上角的英雄头像也是动态加载，而且由于技能之类的图片太多（毕竟有几十个英雄），所以没有办法打成一张静态图集。而如果作为独立图片动态加载，就会多十几个DrawCall。即便是打成多张静态图集，也会导致UI渲染的批次被打断。 #  解决方案：用动态打图集的方式。因为我们没有Unity源码，所以图集的分块算法参考了这个开源项目 http://davikingcode.com/blog/unity-generate-spritesheets-at-runtime/，这个算法效率比较不错，建议大家可以研究一下，它的分块算法的思路上本质上类似于BSP。 #  大图集是在游戏Loading时获得动态图片，然后把这些动态图片渲染到RenderTexture上，用GPU的方式来做可以保证加载的效率。在游戏中，英雄头像使用了一张256x256的RenderTexture，而英雄技能、天赋技能和物品图标使用了一张512x512的RenderTexture。这样一来，技能面板动态图标的消耗从12个DrawCall降低到1个DrawCall。而英雄头像部分，从最多9个DrawCall降低到2个DrawCall，这个结果是因为敌我双方英雄头像使用的材质不同。实际操作中，技能面板的动态图片放在同一个层级里，这样就只有1个DrawCall，上面的蒙板、边框零散图片打成静态图集，在不出现穿插的情况下，UGUI也会协助合批。因此通过这种方式大量减少了DrawCall。后面讲到的一些点其实也用到了动态图集。 #  渲染流水线的原理 #  渲染流程，可以分为三个阶段。应用阶段，几何阶段，光栅化阶段 #  ecs 优缺点，和mvc这些相比。 为啥选ecs #  mvc 面向对象,（继承，多态，封装）高度耦合， 一个英雄charactor包含了 属性，状态，控制器 #  ecs 面向数据：（组合模式）推崇组合优于继承理念，函数式编程，system只对他关系的component负责。业务上更加专一。遍历内存上更加高效（保证内存的连续性）,业务拆分的越细 代码复用率越高 #  帧同步 #  浮点类型，多线程，随机种子，静态变量，全局变量，容器顺序需要确定性 #  内存和虚拟内存的区别 #  指的是把硬盘中的一部分空间用来当做内存使用,虚拟内存的作用：是为了解决计算机在运行较大的程序时内存不足的情况,虚拟内存是在硬盘上的，它的速度要比内存慢的多，虚拟内存其实就是为了运行很大的程序的一种妥协的办法，妥协了软件的运行速度。 #  子类为什么可以赋值给基类对象 #  基类的指针可以指向派生类对象，但是反过来则不行，派生类的指针不可以指向基类的指针。这是为什么呢？这是因为派生类的对象所占的存储空间通常要比基类的对象大，原因就是派生类除了继承基类的成员之外，还拥有自己的成员，所以基类的指针操作派生类的对象时，由于基类指针会向操作基类对象那样操作派生类对象，而基类对象所占用的内存空间通常小于派生类对象，所以基类指针不会超出派生类对象去操作数据。 #  同样的道理，基类的引用可以作为派生类对象的别名，但是反过来则不行，派生类的引用不可以作为基类对象的别名。 #  自定义的UI Mesh #  构造出来的Mesh使用一个单独的正交摄像机来绘制， #  在UI Mesh的构造函数中可以看到是创建了一个GameObject，附加MeshFilter和MeshRenderer，然后再做一些初始化的工作。 #  重点在于自行填充Mesh的三个Buffer：位置、UV和索引。另外为了避免在运行时重复申请内存，在初始化的时候要申请足够多的顶点。 #  在实际游戏中用到了多个UI Mesh，总体的顶点数大概在3000左右。 #  初始化Mesh之后，还要去维护顶点Buffer。一个小兵的血条包含背景底框和前景血条，2个矩形8个顶点，在游戏中去动态地改变这8个顶点的位置。如果某个Actor不在视野中，那么把它所有顶点坍缩到一个点就不显示了。另外，Actor死亡的时候，并不删除它的数据，而是先设置为不显示，然后缓存起来准备复用。也就是说无论整场战斗创建了多少个角色，实际上血条都是在这个Mesh的Buffer里不断复用。 #  ================================================================================================================================ #  (.</description>
    </item>
    
  </channel>
</rss>
