---
title: Interview::unity
date: 2021-06-29 21:46:22 +/-TTTT
categories: [Interview]
tags: [Interview]
---

# Subject  assetBundle.Unload true 和false 区别

	- 当传入的参数为true，则不仅仅内存中的AssetBundle对象包含的资源会被销毁。根据这些资源实例化而来的游戏内的对象也会销毁。

	- 当传入的参数为false，则仅仅销毁内存中的AssetBundle对象包含的资源。

# Unity GC 机制
# 战场优化
## 模型预加载 动态图集 光效粒子 屏幕内外 自定义UIMesh GPU Instancing
# 寻路
# 物理碰撞


# 动态图集的优化原理是什么

# 所谓动态图集就是没有办法静态生成的，需要在运行时动态生成的图集，那么我们为什么需要动态图集？

#动态图集是为了解决游戏中动态图片太多的问题，也就是我们没有办法预先放在UI上的。下图案例中可以看到右下角的英雄技能图标、天赋技能图标，以及主动使用的物品图片，均为动态加载。左上角的英雄头像也是动态加载，而且由于技能之类的图片太多（毕竟有几十个英雄），所以没有办法打成一张静态图集。而如果作为独立图片动态加载，就会多十几个DrawCall。即便是打成多张静态图集，也会导致UI渲染的批次被打断。

#解决方案：用动态打图集的方式。因为我们没有Unity源码，所以图集的分块算法参考了这个开源项目 http://davikingcode.com/blog/unity-generate-spritesheets-at-runtime/，这个算法效率比较不错，建议大家可以研究一下，它的分块算法的思路上本质上类似于BSP。

#大图集是在游戏Loading时获得动态图片，然后把这些动态图片渲染到RenderTexture上，用GPU的方式来做可以保证加载的效率。在游戏中，英雄头像使用了一张256x256的RenderTexture，而英雄技能、天赋技能和物品图标使用了一张512x512的RenderTexture。这样一来，技能面板动态图标的消耗从12个DrawCall降低到1个DrawCall。而英雄头像部分，从最多9个DrawCall降低到2个DrawCall，这个结果是因为敌我双方英雄头像使用的材质不同。实际操作中，技能面板的动态图片放在同一个层级里，这样就只有1个DrawCall，上面的蒙板、边框零散图片打成静态图集，在不出现穿插的情况下，UGUI也会协助合批。因此通过这种方式大量减少了DrawCall。后面讲到的一些点其实也用到了动态图集。


# 渲染流水线的原理
## 渲染流程，可以分为三个阶段。应用阶段，几何阶段，光栅化阶段

# ecs 优缺点，和mvc这些相比。 为啥选ecs

# 帧同步
# 浮点类型，多线程，随机种子，静态变量，全局变量，容器顺序需要确定性
